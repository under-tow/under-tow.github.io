<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.under2.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="undertow &#39;s blog">
<meta property="og:url" content="http://blog.under2.cn/page/4/index.html">
<meta property="og:site_name" content="undertow &#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="undertow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.under2.cn/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>undertow 's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="undertow 's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <!-- 自定义右上角 github -->
    <a target="_blank" rel="noopener" href="https://github.com/under-tow" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <!-- 自定义右上角 github -->

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">undertow 's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/12/04/RabbitMQ%EF%BC%88%E5%9B%9B%EF%BC%89-rabbitmq%E5%9B%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/04/RabbitMQ%EF%BC%88%E5%9B%9B%EF%BC%89-rabbitmq%E5%9B%9B/" class="post-title-link" itemprop="url">RabbitMQ（四）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-04 14:29:57" itemprop="dateCreated datePublished" datetime="2020-12-04T14:29:57+08:00">2020-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:46:17" itemprop="dateModified" datetime="2022-09-22T22:46:17+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="11-SpringBoot整合"><a href="#11-SpringBoot整合" class="headerlink" title="11. SpringBoot整合"></a>11. SpringBoot整合</h2><blockquote>
<p>与SpringBoot整合本文只展示了复杂的Topic模型代码，其他代码可以访问我的<a target="_blank" rel="noopener" href="https://gitee.com/hopestation">Gitee</a></p>
</blockquote>
<p>创建Spring项目，完整的目录结构如下：（与topic有关的我已经标注出来了）</p>
<p><img src="https://hopestation.top/upload/2020/12/boot-mq01-d4874411b0434d1c96712b3543ce227b.png" alt="boot-mq01"></p>
<p>1.导入依赖<code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.配置文件<code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rabbitmq_springboot</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment">#(your ip address)</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">xx.xx.xx.xx</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="comment">#(your pwd)</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="comment">#(your virtual host)</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/ems</span></span><br></pre></td></tr></table></figure>

<p>3.测试类（生产者）<code>TestRabbitMQ.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.hopestation;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="meta">@SpringBootTest(classes = RabbitmqSpringbootApplication.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRabbitMQ</span> &#123;</span><br><span class="line">    <span class="comment">//注入Rabbit</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Toptic</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopic</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;toptics&quot;</span>,<span class="string">&quot;user.save&quot;</span>,<span class="string">&quot;hello toptic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.消费者<code>TopticConsumer.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.hopestation.toptic;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题模式 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopticConsumer</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue,//创建临时队列</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(value = &quot;toptics&quot;,type = &quot;topic&quot;),//绑定交换机</span></span><br><span class="line"><span class="meta">                    key = &#123;&quot;user.*&quot;&#125;//指定路由key数组（这里是主题模式，可以使用通配符）</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">revice1</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="comment">//获取消息</span></span><br><span class="line">        System.err.println(<span class="string">&quot;FanoutConsumer1 get message 【 &quot;</span> + message + <span class="string">&quot; 】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">          @QueueBinding(</span></span><br><span class="line"><span class="meta">                  value = @Queue,</span></span><br><span class="line"><span class="meta">                  exchange = @Exchange(value = &quot;toptics&quot;,type = &quot;topic&quot;),</span></span><br><span class="line"><span class="meta">                  key = &#123;&quot;user.#&quot;,&quot;order.#&quot;&#125;</span></span><br><span class="line"><span class="meta">          )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">revice2</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;FanoutConsumer2 get message 【 &quot;</span> + message + <span class="string">&quot; 】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/12/04/RabbitMQ%EF%BC%88%E4%B8%89%EF%BC%89-rabbitmq%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/04/RabbitMQ%EF%BC%88%E4%B8%89%EF%BC%89-rabbitmq%E4%B8%89/" class="post-title-link" itemprop="url">RabbitMQ（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-04 14:27:31" itemprop="dateCreated datePublished" datetime="2020-12-04T14:27:31+08:00">2020-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:46:14" itemprop="dateModified" datetime="2022-09-22T22:46:14+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目录：<br>[TOC]</p>
<h2 id="9-Routing（路由模型）"><a href="#9-Routing（路由模型）" class="headerlink" title="9.Routing（路由模型）"></a>9.Routing（路由模型）</h2><h3 id="9-1模型认识"><a href="#9-1模型认识" class="headerlink" title="9.1模型认识"></a>9.1模型认识</h3><blockquote>
<p>在<strong>Fanout</strong>模式中，一条消息，会被所有订阅的队列都消费。但是，某些场景下，我们希望不同的消息被不同的队列消费。</p>
<p>这时就要用到Direct类型的Exchange</p>
</blockquote>
<p>在Direct模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由Key）</li>
<li>消息的发送方 在想Exchange发送消息时，也必须指定消息的<code>RoutingKey</code></li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>RoutingKey</code>进行判断，只有队列的<code>RoutingKey</code>与消息的<code>RoutingKey</code>完全一致，才会接受到消息。</li>
</ul>
<p><strong>模型图</strong>：</p>
<p><img src="https://hopestation.top/upload/2020/12/routing02-21c6f89a89304189ac5c8c9bdabb9d99.png" alt="routing02"></p>
<p><strong>图解：</strong></p>
<ul>
<li>P：生产者，向Exchange发送消息，发送消息时，会指定一个<code>RoutingKey</code></li>
<li>X：Exchange【交换机】，接受生产者的消息，然后把消息递交给<code>RoutingKey</code>完全匹配的队列</li>
<li>C1：消费者，其所在队列指定了需要<code>RoutingKey</code>为的<code>error</code>消息</li>
<li>C2：消费者，其所在队列指定了需要<code>RoutingKey</code>为<code>info</code>、<code>warning</code>、<code>error</code>的消息</li>
</ul>
<h3 id="9-2-创建生产者"><a href="#9-2-创建生产者" class="headerlink" title="9.2 创建生产者"></a>9.2 创建生产者</h3><h4 id="9-2-1-编码"><a href="#9-2-1-编码" class="headerlink" title="9.2.1 编码"></a>9.2.1 编码</h4><p>这里与之前的区别主要是：需要指定<code>RoutingKey</code>（路由Key）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> direct;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路由模式 之 Direct</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        <span class="comment">//参数1 交换机的名称：随便起</span></span><br><span class="line">        <span class="comment">//参数2 交换机的类型：固定的几种类型 direct，topic，headers 和fanout</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">//路由Key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;logs_direct&quot;</span>,routingKey,<span class="literal">null</span>,(<span class="string">&quot;Info Message And routingKey is &quot;</span> + routingKey).getBytes());</span><br><span class="line">        RabbitMQUtils.closeConnetctionAndChannel(channel,connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-2-运行结果"><a href="#9-2-2-运行结果" class="headerlink" title="9.2.2 运行结果"></a>9.2.2 运行结果</h4><p>增加了一个<code>logs_direct</code>的交换机，类型为 <code>direct</code></p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201203144805945-bcb34d13179d4cf4bba77ec127eb5a55.png" alt="image-20201203144805945"></p>
<h3 id="9-3-创建消费者"><a href="#9-3-创建消费者" class="headerlink" title="9.3 创建消费者"></a>9.3 创建消费者</h3><h4 id="9-3-1-编码"><a href="#9-3-1-编码" class="headerlink" title="9.3.1 编码"></a>9.3.1 编码</h4><blockquote>
<p>步骤：</p>
<ol>
<li>通道声明交换机 <code>channel.exchangeDeclare(&quot;logs_direct&quot;,BuiltinExchangeType.DIRECT);</code></li>
<li>创建一个临时队列 <code>channel.queueDeclare().getQueue();</code></li>
<li>通道与队列绑定 <code>queueBind(queueName,&quot;logs_direct&quot;,&quot;error&quot;);</code></li>
</ol>
</blockquote>
<p><strong>Consumer1（消费者1）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> direct;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路由模式 之 Direct</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> * 获取路由Key为 info 的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;logs_direct&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//通道声明交换机 参数1 交换机的名字   参数2 交换机的类型与生产者保持一致</span></span><br><span class="line">        <span class="comment">// BuiltinExchangeType.DIRECT 是个枚举 就是 direct</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName,BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//创建一个临时队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//基于RoutingKey绑定队列和交换机</span></span><br><span class="line">        <span class="comment">//参数1 队列名称</span></span><br><span class="line">        <span class="comment">//参数2 交换机名</span></span><br><span class="line">        <span class="comment">//参数3 路由Key</span></span><br><span class="line">        channel.queueBind(queueName,exchangeName,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,<span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="built_in">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer1 get Message = &gt; 【 &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body) + <span class="string">&quot; 】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Consumer2（消费者2）</strong></p>
<p>在队列绑定时多绑定了两种类型，其他与消费者1无区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于RoutingKey绑定队列和交换机</span></span><br><span class="line"><span class="comment">//参数1 队列名称</span></span><br><span class="line"><span class="comment">//参数2 交换机名</span></span><br><span class="line"><span class="comment">//参数3 路由Key</span></span><br><span class="line"><span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;logs_direct&quot;</span>;</span><br><span class="line">channel.queueBind(queueName,exchangeName,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">channel.queueBind(queueName,exchangeName,<span class="string">&quot;warning&quot;</span>);</span><br><span class="line">channel.queueBind(queueName,exchangeName,<span class="string">&quot;error&quot;</span>);</span><br><span class="line"><span class="comment">//下面的代码，变成输出消费者2</span></span><br><span class="line">System.out.println(<span class="string">&quot;Consumer2 get Message = &gt; 【 &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body) + <span class="string">&quot; 】&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-查看结果"><a href="#9-3-2-查看结果" class="headerlink" title="9.3.2 查看结果"></a>9.3.2 查看结果</h4><ol>
<li>先运行两个消费者等待消息，再运行生产者</li>
</ol>
<p><strong>Consumer1</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#没有输出</span></span><br></pre></td></tr></table></figure>

<p><strong>Consumer2</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer2 get Message = &gt; 【 Info Message And routingKey is 【info】 】</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为<strong>Consumer1</strong>只绑定了路由Key【error】，所以接受不到info的消息</p>
<p><code> channel.queueBind(queueName,&quot;logs_direct&quot;,&quot;error&quot;);</code> </p>
</blockquote>
<ol start="2">
<li>改变生产者的路由Key为<code>error</code>运行，再来查看结果</li>
</ol>
<p><strong>Consumer1</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer1 get Message = &gt; 【 Info Message And routingKey is 【error】 】</span><br></pre></td></tr></table></figure>

<p><strong>Consumer2</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer2 get Message = &gt; 【 Info Message And routingKey is 【error】 】</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为<strong>Consumer1</strong>、<strong>Consumer2</strong> 都绑定了路由Key【error】，所以都能接受到消息</p>
<p><code> channel.queueBind(queueName,&quot;logs_direct&quot;,&quot;error&quot;);</code> </p>
<p>路由Key【waring】同理。</p>
</blockquote>
<h2 id="10-Topic-（主题模型）"><a href="#10-Topic-（主题模型）" class="headerlink" title="10. Topic （主题模型）"></a>10. Topic （主题模型）</h2><h3 id="10-1-模型认识"><a href="#10-1-模型认识" class="headerlink" title="10.1 模型认识"></a>10.1 模型认识</h3><p>Topic类型的Exchange与Direct区别：</p>
<ul>
<li><p>相同点：都是可以根据RoutingKey把消息路由到不同的队列。</p>
</li>
<li><p>不同点：Topic类型的Exchange可以让队列在绑定RoutingKey的时候使用通配符！**</p>
</li>
</ul>
<p>这种模型RoutingKey一般都是由一个或者多个单词组成，多个单词之间以”.”分割。例如：<code>item.insert</code></p>
<p><img src="https://hopestation.top/upload/2020/12/topic-03491ab2d4234e10b641366315799ec5.png" alt="topic"></p>
<blockquote>
<p>简而言之，Topic就是对Direct类型的增强，使用了通配符匹配路由Key。</p>
</blockquote>
<h3 id="9-2-创建生产者-1"><a href="#9-2-创建生产者-1" class="headerlink" title="9.2 创建生产者"></a>9.2 创建生产者</h3><h4 id="10-2-1-编码"><a href="#10-2-1-编码" class="headerlink" title="10.2.1 编码"></a>10.2.1 编码</h4><p>代码没有什么改变，主要将<code>Exchange</code>改为<code>Topic</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> topic;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> utils.RabbitMQUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题模式</span></span><br><span class="line"><span class="comment"> *   创建生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//定义 路由key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;user.save&quot;</span>;</span><br><span class="line">        <span class="comment">//定义 路由名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;topics&quot;</span>;</span><br><span class="line">        <span class="comment">//BuiltinExchangeType.TOPIC 是一个枚举</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">//发布消息</span></span><br><span class="line">        channel.basicPublish(exchangeName,routingKey,<span class="literal">null</span>,(<span class="string">&quot;TOPIC Message And routingKey is 【&quot;</span> + routingKey + <span class="string">&quot;】&quot;</span>).getBytes());</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        RabbitMQUtils.closeConnetctionAndChannel(channel,connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="10-2-2-运行结果"><a href="#10-2-2-运行结果" class="headerlink" title="10.2.2 运行结果"></a>10.2.2 运行结果</h4><p>增加了一个<code>topics</code>的交换机，类型为 <code>topic</code></p>
<p><img src="https://hopestation.top/upload/2020/12/topic01-f27e552f2a0949d3a8a80bad5f8cb07b.png" alt="topic01"></p>
<h3 id="10-3-创建消费者"><a href="#10-3-创建消费者" class="headerlink" title="10.3 创建消费者"></a>10.3 创建消费者</h3><h4 id="10-3-1-编码"><a href="#10-3-1-编码" class="headerlink" title="10.3.1 编码"></a>10.3.1 编码</h4><blockquote>
<p>关键代码：使用通配符 ‘‘*“ 绑定路由key</p>
<p><code>  String routingKey = &quot;user.*&quot;;</code></p>
<p><code>     channel.queueBind(queue,exchangeName,routingKey);</code></p>
</blockquote>
<p><strong>Consumer1（消费者1）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> topic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> utils.RabbitMQUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Topic 主题模式</span></span><br><span class="line"><span class="comment"> *  创建消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;topics&quot;</span>;</span><br><span class="line">        <span class="comment">//*（星号）可以代替一个单词。</span></span><br><span class="line">        <span class="comment">//＃（哈希）可以替代零个或多个单词。</span></span><br><span class="line">        <span class="comment">//user.* 就代表 user 和 1个单词 （比如user.del user.save 但是 user.save.ok 不会匹配）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;user.*&quot;</span>;</span><br><span class="line">        channel.exchangeDeclare(exchangeName, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queue</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        channel.queueBind(queue,exchangeName,routingKey);</span><br><span class="line">        channel.basicConsume(queue,<span class="literal">true</span>,<span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="built_in">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer1 get Message = &gt; 【 &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body) + <span class="string">&quot; 】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>Consumer2（消费者2）</strong></p>
<p>使用通配符 ‘‘#“ 绑定路由key，其他重复代码就不贴了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;user.*&quot;</span>;</span><br><span class="line">channel.queueBind(queue,exchangeName,routingKey);</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-查看结果-1"><a href="#9-3-2-查看结果-1" class="headerlink" title="9.3.2 查看结果"></a>9.3.2 查看结果</h4><ol>
<li><p>先运行两个消费者等待消息，再运行生产者</p>
</li>
<li><p>生产者分别指定<strong>routingKey</strong>为<code>user.save</code> , <code>user.save.ok</code> , <code>user</code>。运行了三次结果如下：</p>
</li>
</ol>
<p><strong>Consumer1</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer1 get Message = &gt; 【 TOPIC Message And routingKey is 【user.save】 】</span><br></pre></td></tr></table></figure>

<p><strong>Consumer2</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Consumer2 get Message = &gt; 【 TOPIC Message And routingKey is 【user.save】 】</span><br><span class="line">Consumer2 get Message = &gt; 【 TOPIC Message And routingKey is 【user.save.ok】 】</span><br><span class="line">Consumer2 get Message = &gt; 【 TOPIC Message And routingKey is 【user】 】</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为<strong>Consumer1</strong>只绑定了路由Key 【user.*】;，所以接受不到第2、3条消息</p>
<p>而<strong>Consumer2</strong>绑定了路由Key 【user.#】;，所以都能接受</p>
<p>也可以自己再尝试其他 routingKey 和 通配符进行结果的验证</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/12/02/RabbitMQ%EF%BC%88%E4%BA%8C%EF%BC%89-rabbitmq%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/RabbitMQ%EF%BC%88%E4%BA%8C%EF%BC%89-rabbitmq%E4%BA%8C/" class="post-title-link" itemprop="url">RabbitMQ（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 17:27:55" itemprop="dateCreated datePublished" datetime="2020-12-02T17:27:55+08:00">2020-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:46:10" itemprop="dateModified" datetime="2022-09-22T22:46:10+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目录：<br>[TOC]</p>
<hr>
<blockquote>
<p>上一篇，介绍了Rabbit的概念和安装。这一篇来说MQ的工作模型</p>
</blockquote>
<h2 id="6-HelloWorld（直连模型）"><a href="#6-HelloWorld（直连模型）" class="headerlink" title="6.HelloWorld（直连模型）"></a>6.HelloWorld（直连模型）</h2><p>官网给的向导有这么一张图</p>
<p><img src="https://hopestation.top/upload/2020/12/rabbitmq-type-50832a08a000481794fbe2fc130306cb.png" alt="img"></p>
<p>咱们就先来学习一下第一个<strong>HelloWorld（直连模型）</strong>，模型是这样的：</p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201201172023861-f3631f5bb36f4bdd973e48a91b40f9d6.png" alt="image20201201172023861.png"></p>
<p>在上述模型中有以下概念：</p>
<ul>
<li>P：生产者，发送消息的程序</li>
<li>C：消费者，取出消息，一直等待消息的到来</li>
<li>queue：消息队列，类似一个邮箱，可以缓存消息。生产者向其中投递消息，消费者从中取出消息</li>
</ul>
<p>使用场景：比如注册用户发短信的时候，可以使用这种简单的模型</p>
<h3 id="6-1-准备工作"><a href="#6-1-准备工作" class="headerlink" title="6.1 准备工作"></a>6.1 准备工作</h3><p>首先，需要</p>
<ul>
<li>一个用户。本例是<code>admin</code></li>
<li>一个虚拟主机（且这个用户有权访问这个虚拟主机）。本例是<code>/ems</code></li>
</ul>
<blockquote>
<p>假如是按着上面操作到这里的，这些已经完成了。（消息队列不需要建）</p>
<p>另：我是把MQ部署在了我的Linux服务器上，所以Linux服务器还要开放<code>5672</code>端口，不然会导致：</p>
<p>==&gt; java 连接消息队列 Connection timed out: connect 的异常</p>
</blockquote>
<h3 id="6-2-创建生产者"><a href="#6-2-创建生产者" class="headerlink" title="6.2 创建生产者"></a>6.2 创建生产者</h3><h4 id="6-2-1-编码"><a href="#6-2-1-编码" class="headerlink" title="6.2.1 编码"></a>6.2.1 编码</h4><ol>
<li><p>创建一个Maven项目，目录结构如下：<br><img src="https://hopestation.top/upload/2020/12/01-540da0db8a1548bda1805fa6964f028f.png" alt="image-20201201161900873"></p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>写个Provider类，在helloworld包下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产消息</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接rabbitmq的主机</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;39.105.45.81&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接的端口号</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置连接的虚拟主机</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">        <span class="comment">//设置访问虚拟主机的用户名密码</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;你的密码&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//获取连接的通道对象</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">       <span class="comment">//通道绑定消息队列</span></span><br><span class="line">        <span class="comment">//参数1：队列名称 如果不存在则还会自动创建</span></span><br><span class="line">        <span class="comment">//参数2：durable 用来定义队列特性：队列（不包括消息）是否要持久化 true 持久化队列 false不持久化</span></span><br><span class="line">        <span class="comment">// （若持久化，在mq重启后还队列会存在，false则就不存在了） 注意：无论true false队列里的消息都会消失</span></span><br><span class="line">        <span class="comment">//参数3：exclusive 是否独占队列，true 这个队列只允许当前连接可用 false其他连接也可用</span></span><br><span class="line">        <span class="comment">//实际开发一般设为 false，期望多个连接共享一个队列</span></span><br><span class="line">        <span class="comment">//参数4：autoDelete 是否在消费完成后自动删除队列 true自动删除 false 不知道删除</span></span><br><span class="line">        <span class="comment">//当为true时，1.全部消费完成后，2.且没有消费者进行监听（断开连接）时，==》队列会被自动删除</span></span><br><span class="line">        <span class="comment">//参数5 额外附加参数</span></span><br><span class="line">        <span class="comment">//这里只是声明队列，消息不一定是向这里发送的。生产者和消费者要保持一致</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息 </span></span><br><span class="line">        <span class="comment">//参数1：交换机名称 参数2 队列名称 参数3 传递消息额外设置 参数4 消息的具体内容</span></span><br><span class="line">        <span class="comment">//参数2：这才是消息真正发送到的队列</span></span><br><span class="line">        <span class="comment">//参数3 为：MessageProperties.PERSISTENT_TEXT_PLAIN 表示消息持久化（前提队列也要持久化），然后重启MQ，消息依旧存在</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;hello rabbitmq&quot;</span>.getBytes());</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**声明消息队列的源代码注释</span></span><br><span class="line"><span class="comment">     * Like &#123;<span class="doctag">@link</span> Channel#queueDeclare(String, boolean, boolean, boolean, java.util.Map)&#125; but sets nowait</span></span><br><span class="line"><span class="comment">     * flag to true and returns no result (as there will be no response from the server).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queue the name of the queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> durable true if we are declaring a durable queue (the queue will survive a server restart)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exclusive true if we are declaring an exclusive queue (restricted to this connection)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> autoDelete true if we are declaring an autodelete queue (server will delete it when no longer in use)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments other properties (construction arguments) for the queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// void queueDeclareNoWait(String queue, boolean durable, boolean exclusive, boolean autoDelete,</span></span><br><span class="line">    <span class="comment">//                            Map&lt;String, Object&gt; arguments) throws IOException;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="6-2-2-查看结果"><a href="#6-2-2-查看结果" class="headerlink" title="6.2.2 查看结果"></a>6.2.2 查看结果</h4><ul>
<li>运行</li>
</ul>
<p><img src="https://hopestation.top/upload/2020/12/image-20201201162432634-17ef489f3979400db952015bb71609bb.png" alt="image20201201162432634.png"></p>
<ul>
<li><p>控制台结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#程序没有报异常，正常结束就说明成功了^_^</span></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure></li>
<li><p>管理界面显示结果</p>
<p><img src="https://hopestation.top/upload/2020/12/mqweb02-1def5414a86f4511aa5beb66c2082708.png" alt="img"></p>
</li>
</ul>
<blockquote>
<p>我运行了两次，所以消息总数是2。</p>
</blockquote>
<h3 id="6-3-创建消费者"><a href="#6-3-创建消费者" class="headerlink" title="6.3 创建消费者"></a>6.3 创建消费者</h3><h4 id="6-3-1-编码"><a href="#6-3-1-编码" class="headerlink" title="6.3.1 编码"></a>6.3.1 编码</h4><p>创建一个Consumer类，也是在helloworld包下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建连接工厂</span></span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            connectionFactory.setHost(<span class="string">&quot;39.105.45.81&quot;</span>);</span><br><span class="line">            connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">            connectionFactory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">            connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            connectionFactory.setPassword(<span class="string">&quot;qeeq741&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建连接对象</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//消费消息</span></span><br><span class="line">            <span class="comment">//参数1： 消费的的那个队列的名称</span></span><br><span class="line">            <span class="comment">//参数2：开始消息的自动确认机制</span></span><br><span class="line">            <span class="comment">//参数3：消费时的回调接口</span></span><br><span class="line">            channel.basicConsume(<span class="string">&quot;hello&quot;</span>,<span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    <span class="built_in">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                    System.out.println(<span class="string">&quot;body = &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//假如不关闭就可以一直消费消息</span></span><br><span class="line"><span class="comment">//        channel.close();</span></span><br><span class="line"><span class="comment">//        connection.close();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就不能在Test里写了</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConsumer</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-3-2-查看结果"><a href="#6-3-2-查看结果" class="headerlink" title="6.3.2 查看结果"></a>6.3.2 查看结果</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body = hello rabbitmq</span><br><span class="line">body = hello rabbitmq</span><br><span class="line"><span class="comment">#再运行一次 Provider 发送“body = hello rabbitmq 第三个”</span></span><br><span class="line"><span class="comment">#消费者也会收到这个新消息</span></span><br><span class="line">body = hello rabbitmq 第三个</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意在Consumer里，连接是没有关闭的。<br>这时可以再运行一次生产者，消费者也能立即消费这个新消息。</p>
</blockquote>
<h3 id="6-4-优化代码"><a href="#6-4-优化代码" class="headerlink" title="6.4 优化代码"></a>6.4 优化代码</h3><p>由于生产者和和消费者都来创建<code>ConnectionFactory</code>，比较浪费时间，又是相同的冗余代码。</p>
<p>这里将<strong>创建工厂</strong>，和<strong>关闭资源</strong>的方法封装成了<code>RabbitMQUtils</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConnectionFactory connectionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//重量级及资源， 类加载时只执行一次</span></span><br><span class="line">        connectionFactory = <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;39.105.45.81&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;qeeq741&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供创建连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> connectionFactory.newConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConnetctionAndChannel</span><span class="params">(Channel channel,Connection connection)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(channel!=<span class="literal">null</span>) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(connection!=<span class="literal">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以Provider、Consumer就可以直接调用<code>RabbitMQUtils</code>了。替换比较简单，这里就不再粘贴代码了。<br>我的Gitee会有这部分的代码，可以在那里查看。</p>
</blockquote>
<h2 id="7-Work-Queues（工作队列）"><a href="#7-Work-Queues（工作队列）" class="headerlink" title="7. Work Queues（工作队列）"></a>7. Work Queues（工作队列）</h2><h3 id="7-1-模型认识"><a href="#7-1-模型认识" class="headerlink" title="7.1 模型认识"></a>7.1 模型认识</h3><p>第二个 <strong>Work Queues（工作队列）</strong>模型是这样的：</p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201202151120941-e034e7e842d944a8bfaf7e3db428d078.png" alt="image20201202151120941.png"></p>
<p>与第一种模型很相似，只不过有多个消费者来共同处理队列里的消息。</p>
<p>使用场景：一般在处理队列的任务比较耗时时使用这种模型</p>
<h3 id="7-2-编码"><a href="#7-2-编码" class="headerlink" title="7.2 编码"></a>7.2 编码</h3><p><strong>创建生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接对象</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQUtils.getConnection();</span><br><span class="line"><span class="comment">//获取通道对象</span></span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"><span class="comment">//通过通道，声明工作队列</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;work&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//循环生产消息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;work&quot;</span>,<span class="literal">null</span>,(<span class="string">&quot;Message 【&quot;</span> + i + <span class="string">&quot;】&quot;</span>).getBytes());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;send ok&quot;</span>);</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">RabbitMQUtils.closeConnetctionAndChannel(channel,connection);</span><br></pre></td></tr></table></figure>

<p><strong>创建消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 第一个消费者</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work&quot;</span>,<span class="literal">true</span>,<span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="built_in">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Consumer1 get message = &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第二个消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work&quot;</span>,<span class="literal">true</span>,<span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="built_in">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Consumer2 get message = &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-3-查看结果"><a href="#7-3-查看结果" class="headerlink" title="7.3 查看结果"></a>7.3 查看结果</h3><blockquote>
<p>最好先运行两个消费者，在运行生产者。效果明显。</p>
</blockquote>
<p><strong>生产者</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#发送完毕</span></span><br><span class="line">send ok</span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>

<p><strong>消费者1</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-4 Consumer1 get message = Message 【0】</span><br><span class="line">pool-1-thread-4 Consumer1 get message = Message 【2】</span><br><span class="line">pool-1-thread-4 Consumer1 get message = Message 【4】</span><br><span class="line">pool-1-thread-4 Consumer1 get message = Message 【6】</span><br><span class="line">pool-1-thread-4 Consumer1 get message = Message 【8】</span><br></pre></td></tr></table></figure>

<p><strong>消费者2</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-4 Consumer2 get message = Message 【1】</span><br><span class="line">pool-1-thread-4 Consumer2 get message = Message 【3】</span><br><span class="line">pool-1-thread-4 Consumer2 get message = Message 【5】</span><br><span class="line">pool-1-thread-4 Consumer2 get message = Message 【7】</span><br><span class="line">pool-1-thread-4 Consumer2 get message = Message 【9】</span><br></pre></td></tr></table></figure>

<p>消费者1：0 2 4 6 8 </p>
<p>消费者2：1 3 5 7 9</p>
<p>当我们不断改变生产者，发送消息的数量时，发现消费者1和消费者2总是一个挨着一个的消费消息。</p>
<blockquote>
<p>官网的解释：</p>
<p>By default, RabbitMQ will send each message to the next consumer, in sequence. On average every consumer will get the same number of messages. This way of distributing messages is called round-robin. Try this out with three or more workers.</p>
<p>翻译：</p>
<p>默认情况下，RabbitMQ将按顺序将每条消息发送到下一个使用者。平均每个消费者将收到相同数量的消息。这种分发消息的方式称为循环（轮询）。和三个或更多的工人一起试试这个</p>
</blockquote>
<p>也就是说多个消费者的情况，默认是一个替着一个循环，平均消费队列里的消息的。</p>
<blockquote>
<p>比如队列里有消息：123456789…  有三个消费者<br>消费者1：147..<br>消费者2：258..<br>消费者3：369..<br>多个消费者 以此类推。</p>
</blockquote>
<h2 id="8-Fanout（扇出-广播）"><a href="#8-Fanout（扇出-广播）" class="headerlink" title="8. Fanout（扇出|广播）"></a>8. Fanout（扇出|广播）</h2><p>第三个 <strong>Work Fanout（广播模式</strong> 模型是这样的：</p>
<p><img src="https://hopestation.top/upload/2020/12/fanout-ca0996df1c43454a9a79595e692cf299.png" alt="fanout"></p>
<p>在广播模式下，有以下约定：</p>
<ul>
<li>可以有多个消费者</li>
<li>每个消费者有自己的Queue（队列）</li>
<li>每个队列都要绑定到Exchange（交换机）</li>
<li>生产者发送的消息，只能发送到交换机，交换机来决定要发送给哪个队列，生产者无法决定</li>
<li>交换机把消息发给绑定过的所有队列</li>
<li>队列的消费者都能拿到消息。实现<strong>一条消息被多个消费者消费</strong></li>
</ul>
<p>数据的流向如图的箭头所示。</p>
<blockquote>
<p>官网的解释：</p>
<p>让我们快速回顾一下先前教程中介绍的内容：</p>
<ul>
<li>甲<em>生产者</em>是发送消息的用户的应用程序。</li>
<li>甲<em>队列</em>是一个缓冲区，用于存储消息。</li>
<li>甲<em>消费者</em>是接收消息的用户的应用程序。</li>
</ul>
<p>RabbitMQ消息传递模型中的核心思想是生产者从不将任何消息直接发送到队列。实际上，生产者经常甚至根本不知道是否将消息传递到任何队列。</p>
<p>相反，生产者只能将消息发送到<em>交换机</em>。交流是一件非常简单的事情。一方面，它接收来自生产者的消息，另一方面，将它们推入队列。交换必须确切知道如何处理收到的消息。是否应将其附加到特定队列？是否应该将其附加到许多队列中？还是应该丢弃它。规则由<em>交换类型</em>定义 。</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/exchanges.png" alt="img"></p>
<p>有几种交换类型可用：direct，topic，headers 和fanout。</p>
</blockquote>
<h3 id="8-1-创建生产者"><a href="#8-1-创建生产者" class="headerlink" title="8.1 创建生产者"></a>8.1 创建生产者</h3><h4 id="8-1-1-编码"><a href="#8-1-1-编码" class="headerlink" title="8.1.1 编码"></a>8.1.1 编码</h4><blockquote>
<p>生产者的编码和以前的区别：</p>
<ol>
<li>需要绑定交换机 <code> channel.exchangeDeclare(&quot;logs&quot;,&quot;fanout&quot;);</code></li>
<li>消息放入交换机中 <code>channel.basicPublish(&quot;logs&quot;,&quot;&quot;,null,&quot;my fanout message&quot;.getBytes());</code></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanout;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扇出模式的生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//将通道声明交换机</span></span><br><span class="line">        <span class="comment">//参数1 交换机的名称：随便起</span></span><br><span class="line">        <span class="comment">//参数2 交换机的类型：固定的几种类型 direct，topic，headers 和fanout</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="comment">//广播模式时参数的填写</span></span><br><span class="line">        <span class="comment">// 参数1 交换机名称要写</span></span><br><span class="line">        <span class="comment">// 参数2 路由key不需要指定，空字符串就行</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;my fanout message&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        RabbitMQUtils.closeConnetctionAndChannel(channel,connection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与之前不同的主要是这两处代码：</p>
<ul>
<li><code>channel.exchangeDeclare(&quot;logs&quot;,&quot;fanout&quot;);</code>声明交换机</li>
<li><code> channel.basicPublish(&quot;logs&quot;,&quot;&quot;,null,&quot;my fanout message&quot;.getBytes());</code>参数设置</li>
</ul>
<h4 id="8-1-2-运行结果"><a href="#8-1-2-运行结果" class="headerlink" title="8.1.2 运行结果"></a>8.1.2 运行结果</h4><p><img src="https://hopestation.top/upload/2020/12/image-20201203125509743-912e54a35be0488688ab8aa065a382f2.png" alt="image-20201203125509743"></p>
<p>然后再界面中 显示出了一个新的交换机<code>logs</code>。type为<code>fanout</code></p>
<h3 id="8-2-创建消费者"><a href="#8-2-创建消费者" class="headerlink" title="8.2 创建消费者"></a>8.2 创建消费者</h3><h4 id="8-2-1-编码"><a href="#8-2-1-编码" class="headerlink" title="8.2.1 编码"></a>8.2.1 编码</h4><p>实际代码，一共创建了三个消费者 <code>Consumer1 </code>、<code>Consumer2</code>、<code>Consumer3 </code></p>
<p>这里只贴出<code>Consumer1 </code>的代码，其他两个消费者类似</p>
<blockquote>
<p>消费者的编码和以前的区别：</p>
<ol>
<li>需要绑定交换机 <code> channel.exchangeDeclare(&quot;logs&quot;,&quot;fanout&quot;);</code></li>
<li>创建临时队列 <code>channel.queueDeclare().getQueue();</code></li>
<li>绑定临时队列 <code> channel.queueBind(queueName,&quot;logs&quot;,&quot;&quot;);</code></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> utils.RabbitMQUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扇出模式的消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//通道绑定交换机</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//临时队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//绑定交换机和队列</span></span><br><span class="line">        channel.queueBind(queueName,<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,<span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="built_in">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer1 get Message ==&gt;  【 &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body) + <span class="string">&quot; 】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写其他消费者时,这句话打印的消费者记得换成2和3，以免造成误会</p>
<p><code>System.out.println(&quot;Consumer1 get Message ==&gt;  【 &quot; + new String(body) + &quot; 】&quot;);</code></p>
<h4 id="8-2-2-查看结果"><a href="#8-2-2-查看结果" class="headerlink" title="8.2.2 查看结果"></a>8.2.2 查看结果</h4><p>**Consumer1 **</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer1 get Message ==&gt;  【 my fanout message 】</span><br></pre></td></tr></table></figure>

<p>**Consumer2 **</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer2 get Message ==&gt;  【 my fanout message 】</span><br></pre></td></tr></table></figure>

<p>**Consumer3 **</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer3 get Message ==&gt;  【 my fanout message 】</span><br></pre></td></tr></table></figure>

<p>也就是说<strong>三个消费者都收到了消息队列里的同一条消息</strong>。</p>
<hr>
<ul>
<li>以上就是Helloworld、WorkQueue、Fanout模式的介绍</li>
<li><a target="_blank" rel="noopener" href="https://hopestation.top/archives/rabbitmq03">下一篇</a> 来介绍<strong>路由模式</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/12/02/RabbitMQ%EF%BC%88%E4%B8%80%EF%BC%89-rabbitmq%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/RabbitMQ%EF%BC%88%E4%B8%80%EF%BC%89-rabbitmq%E4%B8%80/" class="post-title-link" itemprop="url">RabbitMQ（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 17:25:58" itemprop="dateCreated datePublished" datetime="2020-12-02T17:25:58+08:00">2020-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:46:19" itemprop="dateModified" datetime="2022-09-22T22:46:19+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目录：</p>
<p>[TOC]</p>
<hr>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="1-MQ是什么"><a href="#1-MQ是什么" class="headerlink" title="1. MQ是什么"></a>1. MQ是什么</h2><h3 id="1-1-Message-Queue"><a href="#1-1-Message-Queue" class="headerlink" title="1.1 Message + Queue"></a>1.1 Message + Queue</h3><blockquote>
<p>在介绍RabbitMQ之前，先来说说什么是MQ</p>
</blockquote>
<p><strong>Message</strong></p>
<p>消息：很简单就是我们的数据</p>
<p><strong>Queue</strong></p>
<p>队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
<p><strong>队列是一种先进先出（First in First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</strong>假设队列是q=（a1,a2,…,an），那么a1就是队头元素，而an是队尾元素。这样我们就可以删除时，总是从a1开始，而插入时，列在最后。这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然在队伍的最后。</p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201130140514722-57b6e8cdeaff4f43b374e5f4ed5ac94d.png" alt="image20201130140514722.png"></p>
<blockquote>
<p>那么，假如队列里的元素不是a，而是消息。就可以称为是简单的消息队列了。</p>
</blockquote>
<h3 id="1-2-MQ的概念"><a href="#1-2-MQ的概念" class="headerlink" title="1.2 MQ的概念"></a>1.2 MQ的概念</h3><p><strong>MQ</strong>（Message Queue）消息队列，是基础数据结构中“先进先出”的一种数据机构。指把要传输的数据（消息）放在队列中，用队列机制来实现消息传递——生产者产生消息并把消息放入队列，然后由消费者去处理。消费者可以到指定队列拉取消息，或者订阅相应的队列，由MQ服务端给其推送消息。 </p>
<ol>
<li>首先得有个队列</li>
<li>生产者：产生消息并把消息放入队列</li>
<li>消费者：从队列里消费消息（拉取、订阅）</li>
</ol>
<p><img src="https://hopestation.top/upload/2020/12/image-20201130153656283-accf383319e84146942d4d8ce1dedb33.png" alt="image20201130153656283.png"></p>
<h3 id="1-3-MQ的作用"><a href="#1-3-MQ的作用" class="headerlink" title="1.3 MQ的作用"></a>1.3 MQ的作用</h3><p>消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。 </p>
<p><strong>解耦</strong>：一个业务需要多个模块共同实现，或者一条消息有多个系统需要对应处理，只需要主业务完成以后，发送一条MQ，其余模块消费MQ消息，即可实现业务，降低模块之间的耦合。</p>
<p><strong>异步</strong>：主业务执行结束后从属业务通过MQ，异步执行，减低业务的响应时间，提高用户体验。</p>
<p><strong>削峰</strong>：高并发情况下，业务异步处理，提供高峰期业务处理能力，避免系统瘫痪。</p>
<h3 id="1-4-MQ的缺点"><a href="#1-4-MQ的缺点" class="headerlink" title="1.4 MQ的缺点"></a>1.4 MQ的缺点</h3><p>1、系统可用性降低。依赖服务也多，服务越容易挂掉。需要考虑MQ瘫痪的情况</p>
<p>2、系统复杂性提高。需要考虑消息丢失、消息重复消费、消息传递的顺序性</p>
<p>3、业务一致性。主业务和从属业务一致性的处理</p>
<blockquote>
<p>可以参考知乎的回答：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/54152397">https://www.zhihu.com/question/54152397</a></p>
</blockquote>
<h2 id="2-MQ有哪些"><a href="#2-MQ有哪些" class="headerlink" title="2. MQ有哪些"></a>2. MQ有哪些</h2><p>消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发RocketMQ等。</p>
<h3 id="2-1-使用场景"><a href="#2-1-使用场景" class="headerlink" title="2.1 使用场景"></a>2.1 使用场景</h3><ol>
<li><strong>Rabbit</strong><br>一般公司真实使用较多。结合Spring框架方便。<br>综合性好。性能好，延时很低；吞吐量到万级，MQ功能比较完备，开源，管理界面不错，社区活跃</li>
<li><strong>Rocket</strong><br>阿里开源，性能好，支持事务（需要购买官方版），能承受高吞吐量<br>对于分布式事务，一致性来说比Kafka好。一般有实力的公司选用。</li>
<li><strong>Kafka</strong><br>大数据、超高吞吐量就选它吧，极高的可用性以及可靠性，而且分布式可以任意扩展。适合数据收集，日志处理<br>对于数据的重复、错误、丢失没有严格的要求</li>
<li><strong>ActiveMq</strong><br>老牌的MQ，有丰富的API，中小型企业受欢迎。但吞吐量不大，目前使用者不算太多。</li>
</ol>
<h3 id="2-2-对比区别"><a href="#2-2-对比区别" class="headerlink" title="2.2 对比区别"></a>2.2 对比区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMq</th>
<th>RabbitMq</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>成熟度</td>
<td>成熟</td>
<td>成熟</td>
<td>比较成熟</td>
<td>成熟的日志领域</td>
</tr>
<tr>
<td>时效性</td>
<td></td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
</tr>
<tr>
<td>社区活跃度</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>
<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>
<td>10万级，RocketMQ也是可以支撑高吞吐的一种MQ</td>
<td>10万级别，这是kafka最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic</td>
<td>topic从几十个到几百个的时候，吞吐量会大幅度下降所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用性</td>
<td>高，基于主从架构实现高可用性</td>
<td>非常高，分布式架构</td>
<td>非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td></td>
<td>经过参数优化配置，可以做到0丢失</td>
<td>经过参数优化配置，消息可以做到0丢失</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ领域的功能极其完备</td>
<td>基于erlang开发，所以并发能力很强，性能极其好，延时很低</td>
<td>MQ功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
<tr>
<td>优劣势总结</td>
<td>非常成熟，功能强大，在业内大量的公司以及项目中都有应用偶尔会有较低概率丢失消息而且现在社区以及国内应用都越来越少，官方社区现维护越来越少，几个月才发布一个版本而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用</td>
<td>rlang语言开发，性能极其好，延时很低；吞吐量到万级，MQ功能比较完备而且开源提供的管理界面非常棒，用起来很好用社区相对比较活跃，几乎每个月都发布几个版本分在国内一些互联网公司近几年用rabbitmq也比较多一些但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。</td>
<td>接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的</td>
<td>kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集</td>
</tr>
</tbody></table>
<h2 id="3-AMQP协议"><a href="#3-AMQP协议" class="headerlink" title="3. AMQP协议"></a>3. AMQP协议</h2><p>Rabbit是基于AMQP协议的</p>
<p>下图是AMQP的协议模型：</p>
<p><img src="https://hopestation.top/upload/2020/12/1538609-20190720105435977-1170222541-35d56e7138df4b608a0a138454933088.png" alt="1538609201907201054359771170222541.png"></p>
<p>正如图中所看到的，AMQP协议模型有三部分组成：生产者、消费者和服务端。</p>
<p>生产者是投递消息的一方，首先连接到Server，建立一个连接，开启一个信道；然后生产者声明交换器和队列，设置相关属性，并通过路由键将交换器和队列进行绑定。同理，消费者也需要进行建立连接，开启信道等操作，便于接收消息。</p>
<p>接着生产者就可以发送消息，发送到服务端中的虚拟主机，虚拟主机中的交换器根据路由键选择路由规则，然后发送到不同的消息队列中，这样订阅了消息队列的消费者就可以获取到消息，进行消费。</p>
<h2 id="4-Rabbit的安装"><a href="#4-Rabbit的安装" class="headerlink" title="4. Rabbit的安装"></a>4. Rabbit的安装</h2><blockquote>
<p>可以从官网下载，但一般比较缓慢（可以往下看，我分享了3.8.3版本的百度云链接）</p>
</blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">1. 官网界面</a>：点击Get Started</strong></p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201130163532286-2a95584e2da242319c12de27b509f726.png" alt="image20201130163532286.png"></p>
<p><strong>2. 点击DownLoad，然后进行选择</strong></p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201130164031038-a09304938494430788b5c944653ce1d1.png" alt="image20201130164031038.png"></p>
<blockquote>
<p>我是部署到了租的CentOs服务器上面，也就是说下面讲的是Linux的部署方式</p>
</blockquote>
<h3 id="4-1-安装Erlang"><a href="#4-1-安装Erlang" class="headerlink" title="4.1 安装Erlang"></a>4.1 安装Erlang</h3><h4 id="4-1-1-下载Erlang"><a href="#4-1-1-下载Erlang" class="headerlink" title="4.1.1 下载Erlang"></a>4.1.1 下载Erlang</h4><p>RabbitMQ是Erlang语言编写，所以Erang环境必须要有</p>
<p>注：Erlang环境一定要与RabbitMQ版本匹配：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a></p>
<p><strong>Erlang下载</strong>:</p>
<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1GsPsvfTDyzERPjiZ3wrvWg">https://pan.baidu.com/s/1GsPsvfTDyzERPjiZ3wrvWg</a> </li>
<li>提取码：uzvm </li>
</ul>
<blockquote>
<p>Erlang其他下载地址：</p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/releases/erlang/%EF%BC%88%E6%A0%B9%E6%8D%AE%E8%87%AA%E8%BA%AB%E9%9C%80%E6%B1%82%E5%8F%8A%E5%8C%B9%E9%85%8D%E5%85%B3%E7%B3%BB%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94rpm%E5%8C%85%EF%BC%89">https://www.rabbitmq.com/releases/erlang/（根据自身需求及匹配关系，下载对应rpm包）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.erlang.org/downloads">https://www.erlang.org/downloads</a></p>
<p><a target="_blank" rel="noopener" href="http://erlang.org/download/">http://erlang.org/download/</a> <strong>推荐</strong></p>
</blockquote>
<h4 id="4-1-2-安装Erlang编译安装必要依赖"><a href="#4-1-2-安装Erlang编译安装必要依赖" class="headerlink" title="4.1.2 安装Erlang编译安装必要依赖"></a>4.1.2 安装Erlang编译安装必要依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#没有换行是一句话，太长了</span></span><br><span class="line">sudo yum install -y gcc gcc-c++ glibc-devel make ncurses-devel openssl-devel autoconf java-1.8.0-openjdk-devel git</span><br></pre></td></tr></table></figure>



<h4 id="4-1-3-编译并安装"><a href="#4-1-3-编译并安装" class="headerlink" title="4.1.3 编译并安装"></a>4.1.3 编译并安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.首先将刚刚下载的erlang的压缩包，上传到的你服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.利用cd命令，进入到压缩包的目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.解压</span></span><br><span class="line">tar -zxvf otp_src_22.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#4. 进入otp_src_22.3目录</span></span><br><span class="line"><span class="built_in">cd</span> otp_src_22.3/</span><br><span class="line"></span><br><span class="line"><span class="comment">#5. 编译&amp;安装 （执行下面的两个命令）</span></span><br><span class="line">./otp_build autoconf</span><br><span class="line"></span><br><span class="line">./configure &amp;&amp; make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<p>默认安装在/usr/local/lib/erlang/目录下</p>
<h4 id="4-1-4-验证"><a href="#4-1-4-验证" class="headerlink" title="4.1.4 验证"></a>4.1.4 验证</h4><p><strong>1. 查看erl 版本</strong> ：<code>erl -version</code></p>
<blockquote>
<p>Erlang (SMP,ASYNC_THREADS,HIPE) (BEAM) emulator version xx.x</p>
</blockquote>
<p><strong>2. 执行erl</strong> ：<code>erl</code></p>
<blockquote>
<p>Erlang/OTP 22 [erts-10.7] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:1] [hipe]</p>
<ol>
<li>Eshell V10.7  (abort with ^G)</li>
<li>1&gt;</li>
</ol>
<p>我是直接 Ctrl  + C 退出 erl命令的</p>
</blockquote>
<p>以上是Erlang的安装，还是有点hard的。接下来才到主角<strong>RabbitMq</strong>的安装（simpler）</p>
<blockquote>
<p>我当时就差点被这个安装包和安装劝退了..要坚持下来</p>
</blockquote>
<h3 id="4-2-安装Rabbit"><a href="#4-2-安装Rabbit" class="headerlink" title="4.2 安装Rabbit"></a>4.2 安装Rabbit</h3><h4 id="4-2-1-下载"><a href="#4-2-1-下载" class="headerlink" title="4.2.1 下载"></a>4.2.1 下载</h4><ol>
<li><p>百度云下载，再上传到服务器（推荐）</p>
<p>再给个百度云链接，一步到胃 ^ _ ^</p>
<p><strong>rabbitmq-server-generic-unix-3.8.3.tar.xz</strong></p>
<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1grH-RhZSoKy-heqQ6XBQ-g">https://pan.baidu.com/s/1grH-RhZSoKy-heqQ6XBQ-g</a> </li>
<li>提取码：qixr </li>
</ul>
</li>
<li><p>下面这个命令也可以直接获取rabbitmq-server（但一般下载很慢，或不能下载 。不推荐）</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.8.3/rabbitmq-server-generic-unix-3.8.3.tar.xz</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>其他下载链接</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-server/releases">https://github.com/rabbitmq/rabbitmq-server/releases</a> 推荐</p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/install-rpm.html">https://www.rabbitmq.com/install-rpm.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/releases/rabbitmq-server/">https://www.rabbitmq.com/releases/rabbitmq-server/</a></p>
<p><a target="_blank" rel="noopener" href="https://dl.bintray.com/rabbitmq/all/rabbitmq-server/">https://dl.bintray.com/rabbitmq/all/rabbitmq-server/</a>  推荐</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-generic-unix-3.8.3.tar.xz">rabbitmq-server-generic-unix-3.8.3.tar.xz</a></p>
</blockquote>
</li>
</ol>
<h4 id="4-2-2-解压"><a href="#4-2-2-解压" class="headerlink" title="4.2.2 解压"></a>4.2.2 解压</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 将刚刚的压缩包上传到服务器</span></span><br><span class="line"><span class="comment">#2. 利用cd目录 进入压缩包的目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 解压 (执行下面两个命令)</span></span><br><span class="line">xz -d rabbitmq-server-generic-unix-3.8.3.tar.xz</span><br><span class="line"></span><br><span class="line">tar -xvf rabbitmq-server-generic-unix-3.8.3.tar</span><br><span class="line"></span><br><span class="line"><span class="comment">#4. 移动到 /usr/local/ 目录下</span></span><br><span class="line"><span class="built_in">mv</span> rabbitmq_server-3.8.3 /usr/local/</span><br></pre></td></tr></table></figure>



<h4 id="4-2-3-配置环境变量"><a href="#4-2-3-配置环境变量" class="headerlink" title="4.2.3 配置环境变量"></a>4.2.3 配置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编辑配置文件</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment"># 在最后一行添加如下命令</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/lib/erlang/bin:/usr/local/rabbitmq_server-3.8.3/sbin</span><br><span class="line"><span class="comment">#使环境变量生效（source命令通常用于重新执行刚修改的初始化文件，使之立即生效）</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p>附上一个图</p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201201094631802-f368fa400c7a4b39b38d728bbf2a66b5.png" alt="image20201201094631802.png"></p>
<h3 id="4-3-启动MQ"><a href="#4-3-启动MQ" class="headerlink" title="4.3 启动MQ"></a>4.3 启动MQ</h3><blockquote>
<p>报错 ERROR: node with name “rabbit” already running on “VM_0_2_centos”</p>
<p>如果启动不了 看一下进程里是否已启动</p>
<p>我自己是一次运行成功了，没有出错</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 开启管理界面的插件</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line"><span class="comment">#2. 运行</span></span><br><span class="line">rabbitmq-server 或 rabbitmq-server -detached(后台运行)</span><br></pre></td></tr></table></figure>

<p>显示成这样就是成功啦^_^</p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201201100541313-db6d5054bdf24a4f99ad6627d984ecdd.png" alt="image20201201100541313.png"></p>
<h4 id="4-3-1-添加新用户"><a href="#4-3-1-添加新用户" class="headerlink" title="4.3.1 添加新用户"></a>4.3.1 添加新用户</h4><ul>
<li>默认账号密码是（guest/guest），外网不能访问，但可以修改设置</li>
<li>还可以添加新用户（外网可以访问）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新添加账号：用户名：admin 密码：admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 添加命令</span></span><br><span class="line">rabbitmqctl add_user admin admin（这里可以写你的密码）</span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 设置管理员角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-访问后台"><a href="#4-3-2-访问后台" class="headerlink" title="4.3.2 访问后台"></a>4.3.2 访问后台</h4><p><a target="_blank" rel="noopener" href="http://localhost:15672/">http://localhost:15672</a> 或者 你的ip:15672</p>
<p>输入你的用户名密码</p>
<p>就进入了RabbitMq的控制界面，实际开发中一般用这个界面比较多。也可能使用命令行的方式。</p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201201101054756-0e3200f819c04e68a98d7b6065610cf0.png" alt="image20201201101054756.png"></p>
<h4 id="4-3-3-其他操作"><a href="#4-3-3-其他操作" class="headerlink" title="4.3.3 其他操作"></a>4.3.3 其他操作</h4><ol>
<li>停止MQ</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl shutdown</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>解除guest账户的本地登录限制</p>
<p>修改核心配置参数<br>rabbitmq的核心配置参数在/usr/local/rabbitmq_server-3.8.3/ebin/rabbit.app里</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/rabbitmq_server-3.8.3/ebin/rabbit.app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到loopback_users 修改为如下内容（去除 &lt;&lt;&quot;guest&quot;&gt;&gt;中&lt;&lt;&quot;&quot;&gt;&gt;） &#123;loopback_users, [guest]&#125;,</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示命令帮助</span></span><br><span class="line">rabbitmqctl <span class="built_in">help</span></span><br><span class="line"><span class="comment">#插件命令帮助</span></span><br><span class="line">rabbitmq-plugins</span><br><span class="line"><span class="comment">#插件</span></span><br><span class="line">看插件打开情况：rabbitmq-plugins list</span><br><span class="line"></span><br><span class="line">启动监控管理器：rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line"></span><br><span class="line">关闭监控管理器：rabbitmq-plugins <span class="built_in">disable</span> rabbitmq_management</span><br><span class="line"><span class="comment">#队列</span></span><br><span class="line"></span><br><span class="line">查看所有的队列：rabbitmqctl list_queues</span><br><span class="line"></span><br><span class="line">清除所有的队列：rabbitmqctl reset</span><br><span class="line"><span class="comment">#状态</span></span><br><span class="line"></span><br><span class="line">查看状态：rabbitmqctl status</span><br><span class="line"></span><br><span class="line">查看集群状态：rabbitmqctl cluster_status</span><br><span class="line"></span><br><span class="line">集群同步：</span><br><span class="line"></span><br><span class="line">所有节点的值相同：/var/lib/rabbitmq/.erlang.cookie</span><br><span class="line"></span><br><span class="line">加入集群：</span><br><span class="line"></span><br><span class="line">host1和host2，在host2上操作</span><br><span class="line"></span><br><span class="line">先停止：rabbitmqctl -n rabbit stop_app</span><br><span class="line"></span><br><span class="line">加入：rabbitmqctl -n rabbit join_cluster rabbit@<span class="variable">$rabbit_hostname1</span></span><br><span class="line"></span><br><span class="line">再启动：rabbitmqctl -n rabbit start_app</span><br><span class="line"></span><br><span class="line"><span class="comment">#用户管理</span></span><br><span class="line"></span><br><span class="line">新增 rabbitmqctl add_user admin admin</span><br><span class="line"></span><br><span class="line">删除 rabbitmqctl delete_user admin</span><br><span class="line"></span><br><span class="line">修改 rabbitmqctl change_password admin admin123</span><br><span class="line"></span><br><span class="line">用户列表 rabbitmqctl  list_users</span><br><span class="line"></span><br><span class="line">设置角色 rabbitmqctl set_user_tags admin administrator monitoring policymaker management</span><br><span class="line"></span><br><span class="line">设置用户权限 rabbitmqctl  set_permissions  -p  VHostPath  admin  ConfP  WriteP  ReadP</span><br><span class="line"></span><br><span class="line">查询所有权限 rabbitmqctl  list_permissions  [-p  VHostPath]</span><br><span class="line"></span><br><span class="line">指定用户权限 rabbitmqctl  list_user_permissions  admin</span><br><span class="line"></span><br><span class="line">清除用户权限 rabbitmqctl  clear_permissions  [-p VHostPath]  admin</span><br><span class="line"></span><br><span class="line"><span class="comment">#多应用使用</span></span><br><span class="line"></span><br><span class="line">rabbitmqctl -n rabbit_ceilometer 命令</span><br></pre></td></tr></table></figure>



<blockquote>
<p>安装部分参考自:<em>我是Superman丶</em>的<a target="_blank" rel="noopener" href="https://blog.csdn.net/G971005287W/article/details/106090600?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control">文章</a></p>
</blockquote>
<h2 id="5-管理界面初识"><a href="#5-管理界面初识" class="headerlink" title="5.管理界面初识"></a>5.管理界面初识</h2><h3 id="5-1-概览界面"><a href="#5-1-概览界面" class="headerlink" title="5.1 概览界面"></a>5.1 概览界面</h3><p><img src="https://hopestation.top/upload/2020/12/mqweb01-fda2f10010e94bcf9fbed2008328f44e.png" alt="img"></p>
<h3 id="5-2-交换机界面"><a href="#5-2-交换机界面" class="headerlink" title="5.2  交换机界面"></a>5.2  交换机界面</h3><p><img src="https://hopestation.top/upload/2020/12/mqweb-0335203fcd794c229222e3ce3661d50c.png" alt="img"></p>
<h3 id="5-3-Admin界面"><a href="#5-3-Admin界面" class="headerlink" title="5.3 Admin界面"></a>5.3 Admin界面</h3><h4 id="5-3-1-用户授权"><a href="#5-3-1-用户授权" class="headerlink" title="5.3.1 用户授权"></a>5.3.1 用户授权</h4><p>进入用户管理，我们之前添加的admin用户还没有权限。<br>点击Name一栏的<code>admin</code>，为其设置权限</p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201201112505595-882a0d8111404d289ac1c5eb5cea8ec7.png" alt="image20201201112505595.png"></p>
<p>一进来默认的信息已经填好了，直接点击<code>Set permission</code> 批准即可</p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201201130121379-c339ee63020f48aea2fa5b7230f2a5a0.png" alt="image20201201130121379.png">Q.assets\image-20201201130121379.png)</p>
<h4 id="5-3-2-创建虚拟主机"><a href="#5-3-2-创建虚拟主机" class="headerlink" title="5.3.2 创建虚拟主机"></a>5.3.2 创建虚拟主机</h4><p>Admin -&gt; Virtual Hosts -&gt; Add a new virtual hosts</p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201201125843432-79f3757f356c4ca499da7e84460cff6a.png" alt="image20201201125843432.png"></p>
<p>以上就是Rabbit的介绍好安装啦，<a target="_blank" rel="noopener" href="https://hopestation.top/archives/rabbitmq02">下一篇</a>来实战编码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/12/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/" class="post-title-link" itemprop="url">并发编程（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 08:55:30" itemprop="dateCreated datePublished" datetime="2020-12-01T08:55:30+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:47:33" itemprop="dateModified" datetime="2022-09-22T22:47:33+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://gitee.com/hopestation/thread-learn"><img src="https://gitee.com/hopestation/thread-learn/widgets/widget_card.svg?colors=393222,ebdfc1,fffae5,d8ca9f,393222,a28b40" alt="hopeStation/thread-learn"></a></p>
<h2 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h2><h2 id="异步回调（Future）"><a href="#异步回调（Future）" class="headerlink" title="异步回调（Future）"></a>异步回调（Future）</h2><p>设计的初衷：对将来的某个时间的结果进行建模</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>JMM即为JAVA 内存模型（java memory model），是一个概念</p>
<h3 id="关于JMM的一些约定"><a href="#关于JMM的一些约定" class="headerlink" title="关于JMM的一些约定"></a>关于JMM的一些约定</h3><ol>
<li>线程解锁前<br>必须把共享变量<strong>立刻刷回主存</strong></li>
<li>线程加锁前<br>必须把读取<strong>主存</strong>中的<strong>最新值</strong>到线程的<strong>工作内存</strong>中</li>
<li>加锁和解锁 是同一把锁</li>
</ol>
<h3 id="八个操作"><a href="#八个操作" class="headerlink" title="八个操作"></a>八个操作</h3><p><img src="https://hopestation.top/upload/2020/12/image-20201126165607193-cea87a2c89ad4f60a7a66712de9a63a4.png" alt="image20201126165607193.png"></p>
<h3 id="八种线程之间的交互指令"><a href="#八种线程之间的交互指令" class="headerlink" title="八种线程之间的交互指令"></a>八种线程之间的交互指令</h3><ol>
<li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状 。</li>
<li><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read（读取）</strong>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ol>
<h3 id="JMM对交互指令的约束"><a href="#JMM对交互指令的约束" class="headerlink" title="JMM对交互指令的约束"></a>JMM对交互指令的约束</h3><p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。</p>
<p>Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>提供轻量级的同步机制</p>
<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ul>
<h4 id="什么是指令重排"><a href="#什么是指令重排" class="headerlink" title="什么是指令重排"></a>什么是指令重排</h4><p>你写的程序，计算机并不是按照你写的那样去执行的</p>
<p>源代码 -&gt; 编译器优化的重排 -&gt; 指令并行也可能会重排 -&gt; 内存系统也会重排 -&gt; 执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">//2</span></span><br><span class="line">x = x + <span class="number">1</span>;<span class="comment">//3</span></span><br><span class="line">y = y + x; <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>真正的的执行顺序不一定是 1234，有可能是 2134，1324</p>
<p>但不可呢是 1243 ，因为 <strong>处理器在进行指令重排时，会考虑数据之间的依赖性</strong>，不会影响正确的结果</p>
<p>但是在多线程的情况下，可能会出错，举个例子：</p>
<p>x,y,a,b的初始值都是0</p>
<table>
<thead>
<tr>
<th>顺序</th>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>先执行</td>
<td>x=a</td>
<td>y=b</td>
</tr>
<tr>
<td>后执行</td>
<td>b=1</td>
<td>a=2</td>
</tr>
</tbody></table>
<p>正确的执行结果 x=0,y=0</p>
<p>指令重排后的顺序也可能变成</p>
<table>
<thead>
<tr>
<th>顺序</th>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>先执行</td>
<td>b=1</td>
<td>a=2</td>
</tr>
<tr>
<td>后执行</td>
<td>x=a</td>
<td>y=b</td>
</tr>
</tbody></table>
<p>正确的执行结果 x=2,y=1</p>
<p><strong>volatile可以避免指令重排</strong></p>
<ol>
<li>保证特定操作的执行顺序</li>
<li>可以保证某些变量的内存可见性</li>
</ol>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>坑：</p>
<p>Integer（-128~127比较特殊）</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁</strong>是<strong>指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</strong>，若无外力作用，它们都将无法推进下去。此时称系统处于<strong>死锁状态</strong>或系统产生了<strong>死锁</strong>，这些永远在互相等待的进程称为<strong>死锁进程</strong>。</p>
<p><img src="https://hopestation.top/upload/2020/12/image-20201130103019041-8c72ca3a837e4d73b95ef8baed48c98b.png" alt="image20201130103019041.png"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><blockquote>
<p>不推荐使用String类型 作为锁对象</p>
<p>String对象存在于常量池中，相同内容的String对象地址相同，为同一对象。因此如果使用String作为锁时，如果之前设置String对象锁的值与后面设置的锁对应的String对象值相同则会影响代码的执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDeadLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须是static的，</span></span><br><span class="line"><span class="comment">     * 在main方法里，创建了两个对象，如果不是静态的，就变成了每一个对象都有o1 o2，无法造成死锁</span></span><br><span class="line"><span class="comment">     * static来保证：两个线程 来争夺这相同的这两个对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyDeadLock</span><span class="params">(<span class="type">boolean</span> flag)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.flag)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get lock o1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get lock o2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get lock o2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get lock o1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyDeadLock</span>(<span class="literal">true</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyDeadLock</span>(<span class="literal">false</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="排查死锁"><a href="#排查死锁" class="headerlink" title="排查死锁"></a>排查死锁</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看进程号</span></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_181\bin&gt;jps -l</span><br><span class="line">7952 lock.Test</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息</span></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_181\bin&gt;jstack 7952</span><br><span class="line">...</span><br><span class="line"><span class="comment">#发现了死锁</span></span><br><span class="line"><span class="comment">#Found one Java-level deadlock</span></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">  waiting to lock monitor 0x00000000575bae38 (object 0x00000000d70b8190, a java.</span><br><span class="line">lang.Object),</span><br><span class="line">  <span class="built_in">which</span> is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">  waiting to lock monitor 0x00000000575b8448 (object 0x00000000d70b81a0, a java.</span><br><span class="line">lang.Object),</span><br><span class="line">  <span class="built_in">which</span> is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">        at lock.MyDeadLock.run(MyDeadLock.java:45)</span><br><span class="line">        - waiting to lock &lt;0x00000000d70b8190&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d70b81a0&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">        at lock.MyDeadLock.run(MyDeadLock.java:31)</span><br><span class="line">        - waiting to lock &lt;0x00000000d70b81a0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d70b8190&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"><span class="comment">#Found 1 deadlock.</span></span><br><span class="line">Found 1 deadlock.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>排查问题：</p>
<ul>
<li>查看日志</li>
<li>查看堆栈信息</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/12/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/" class="post-title-link" itemprop="url">并发编程（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 08:44:05" itemprop="dateCreated datePublished" datetime="2020-12-01T08:44:05+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:47:29" itemprop="dateModified" datetime="2022-09-22T22:47:29+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://gitee.com/hopestation/thread-learn"><img src="https://gitee.com/hopestation/thread-learn/widgets/widget_card.svg?colors=393222,ebdfc1,fffae5,d8ca9f,393222,a28b40" alt="hopeStation/thread-learn"></a></p>
<h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><p>并发修改异常<br>java.util.ConcurrentModificationException</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/myseries/p/10877420.html">https://www.cnblogs.com/myseries/p/10877420.html</a></p>
<h2 id="JUC辅助类"><a href="#JUC辅助类" class="headerlink" title="JUC辅助类"></a>JUC辅助类</h2><h2 id="BlockQueue"><a href="#BlockQueue" class="headerlink" title="BlockQueue"></a>BlockQueue</h2><p><strong>四组API</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>抛出异常</th>
<th>不抛出异常</th>
<th>失败等待</th>
<th>时间段等待</th>
</tr>
</thead>
<tbody><tr>
<td>增加操作</td>
<td>add()</td>
<td>offer()</td>
<td>put()</td>
<td>offer(…)</td>
</tr>
<tr>
<td>取出操作</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(..)</td>
</tr>
<tr>
<td>查看队首元素</td>
<td>element()</td>
<td>peek()</td>
<td>.</td>
<td>.</td>
</tr>
</tbody></table>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h4 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h4><p>简单点来说，就是提前保存大量的资源，以备不时之需。</p>
<p>对于线程，内存，oracle的连接对象等等，这些都是资源，程序中当你创建一个线程或者在堆上申请一块内存时，都涉及到很多系统调用，也是非常消耗CPU的，如果你的程序需要很多类似的工作线程或者需要频繁的申请释放小块内存，如果没有在这方面进行优化，那很有可能这部分代码将会成为影响你整个程序性能的瓶颈。</p>
<h4 id="常见的池化技术"><a href="#常见的池化技术" class="headerlink" title="常见的池化技术"></a>常见的池化技术</h4><ul>
<li>线程池</li>
<li>连接池</li>
<li>内存池</li>
<li>对象池</li>
</ul>
<blockquote>
<p>参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/syviah/article/details/46550161">https://blog.csdn.net/syviah/article/details/46550161</a></p>
<ol>
<li><p>对象池<br>就是提前创建很多对象，将用过的对象保存起来，等下一次需要这种对象的时候，再拿出来重复使用</p>
</li>
<li><p>线程池</p>
<p>线程池的原理很简单，类似于操作系统中的缓冲区的概念，它的流程如下：</p>
<p>先启动若干数量的线程，并让这些线程都处于睡眠状态，当客户端有一个新请求时，就会唤醒线程池中的某一个睡眠线程，让它来处理客户端的这个请求，当处理完这个请求后，线程又处于睡眠状态。</p>
<p>可能你也许会问：为什么要搞得这么麻烦，如果每当客户端有新的请求时，我就创建一个新的线程不就完了？这也许是个不错的方法，因为它能使得你编写代码相对容易一些，但你却忽略了一个重要的问题??性能！</p>
<p>一个省级数据大集中的银行网络中心，高峰期每秒的客户端请求并发数超过100，如果为每个客户端请求创建一个新线程的话，那耗费的CPU时间和内存将是惊人的，如果采用一个拥有200个线程的线程池，那将会节约大量的的系统资源，使得更多的CPU时间和内存用来处理实际的商业应用，而不是频繁的线程创建与销毁。</p>
</li>
<li><p>内存池</p>
<p>如何更好的管理在应用程序中内存的使用，同时提高内存使用的效率，这是值得每一个开发人员深思的问题。内存池(Memory pool)提供了一种比较可行的解决方案。首先是创建内存池。这个过程的主要任务是预先分配足够大的内存，形成一个初步的“内存池”。分配内存，也就是用户请求内存时，会返回内存池中一块空闲的内存，并将其标志置为已使用，当然具体细节和方法有很多。释放内存时，不是真正地调用free或是delete的过程，而是把内存放回内存池的过程。在把内存放入内存池的同时，要把标志位置为空闲。最后在应用程序结束时，要把内存池销毁。这里主要做的工作就是把内存池中的每一块内存释放。</p>
<p>使用内存池的好处：</p>
<p>1、减少了内存碎片的产生。这个可以从创建内存池的过程中看出。我们在创建内存池时，分配的都是一块块比较整的内存块，这样可以减少内存碎片的产生。</p>
<p> 2、提高了内存的使用效率。这个可以从分配内存和释放内存的过程中看出。每次的分配与释放并不是去调用系统提供的函数或是操作符去操作实际的内存，而是在复用内存池中的内存。</p>
<p>缺点：</p>
<p>就是很有可能会造成内存的浪费，原因也很明显，开始分配了一大块内存，不是全部都用得到的。</p>
</li>
<li><p>数据库连接池</p>
<p>连接池比较典型的有oracle的连接池。</p>
<p> 数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的 性能低下。</p>
<p>数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。</p>
<p>  连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。</p>
<ol>
<li><p>最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费；</p>
</li>
<li><p>最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。 </p>
</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h4><ul>
<li>降低资源的消耗（资源复用）</li>
<li>提升响应速度（拿来就用）</li>
<li>方便管理</li>
</ul>
<p>线程可以复用，可以控制最大并发数！</p>
<h4 id="线程池必会"><a href="#线程池必会" class="headerlink" title="线程池必会"></a>线程池必会</h4><p>3大方法，7大参数，4种拒绝策略</p>
<h4 id="三大方法"><a href="#三大方法" class="headerlink" title="三大方法"></a>三大方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//创建一个固定的线程池的大小</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//可伸缩的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Executors</span>.FinalizableDelegatedExecutorService(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(var0, var0, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, <span class="number">2147483647</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> :</span><br><span class="line">    AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h4><ol>
<li><p><strong>corePoolSize</strong>: 核心线程数</p>
</li>
<li><p><strong>maximumPoolSize</strong>允许创建的最大线程数</p>
</li>
<li><p><strong>keepAliveTime</strong>： 这个看一下单词也能猜出它的主要作用了吧？当线程池的线程数大于核心线程数的时候，线程空闲时间超过这个时间后还没有任务给它做的话就会关闭。小于等于核心线程数的时候不会被关闭，但是可以通过public void allowCoreThreadTimeOut(true)来设置使其可以被关闭。</p>
</li>
<li><p><strong>TimeUnit</strong> unit：keepAliveTime的时间单位(作转换用)<br>this.keepAliveTime = unit.toNanos(keepAliveTime);</p>
</li>
<li><p><strong>BlockingQueue</strong> workQueue: 任务队列</p>
</li>
<li><p><strong>ThreadFactory</strong> threadFactory: 生成线程的工厂，另一个重载的方法就是带有这个参数的。</p>
</li>
<li><p><strong>RejectedExecutionHandler</strong> handler 当线程池满了，但还有新任务提交的时候，就会采用这个策略来进行处理 ThreadPoolExecutor 中已经定义好四个实现类了：</p>
</li>
</ol>
<h4 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h4><ul>
<li><p>public static class AbortPolicy implements RejectedExecutionHandler；</p>
<p>直接抛出 RejectedExecutionException 异常，这个是默认的处理策略。</p>
</li>
<li><p>public static class CallerRunsPolicy implements RejectedExecutionHandler；</p>
<p>如果线程池没有被关闭，就交由提交任务的线程来执行。</p>
</li>
<li><p>public static class DiscardOldestPolicy implements RejectedExecutionHandler</p>
<p>这个策略就是讲等待队列头的任务给扔掉，然后将这个新任务提交到等待队列中。</p>
</li>
<li><p>public static class DiscardPolicy implements RejectedExecutionHandler</p>
<p>   丢弃任务，不做任何处理。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/11/27/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88%E8%BD%AC%EF%BC%89-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E8%BD%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/27/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88%E8%BD%AC%EF%BC%89-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E8%BD%AC/" class="post-title-link" itemprop="url">可重入锁、不可重入锁（转）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-27 17:13:13" itemprop="dateCreated datePublished" datetime="2020-11-27T17:13:13+08:00">2020-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:48:16" itemprop="dateModified" datetime="2022-09-22T22:48:16+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文作者：航海到IT的转变,梦想一直在路上<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wb_zjp283121/article/details/88973970">https://blog.csdn.net/wb_zjp283121/article/details/88973970</a></p>
</blockquote>
<br>

<h1 id="什么是可重入锁与不可重入锁？"><a href="#什么是可重入锁与不可重入锁？" class="headerlink" title="什么是可重入锁与不可重入锁？"></a><strong>什么是可重入锁与不可重入锁？</strong></h1><p>“<strong>可重入锁</strong>”这四个字分开来解释：</p>
<ul>
<li><strong>可</strong>：可以。</li>
<li><strong>重</strong>：再次。</li>
<li><strong>入</strong>：进入。</li>
<li><strong>锁</strong>：同步锁。</li>
</ul>
<p>综上所述，“<strong>可重入锁</strong>”就是这把同步锁可以再次进入。</p>
<p>进入什么？</p>
<p>进入<strong>同步域（即同步代码块/方法或显式锁锁定的代码）</strong>。</p>
<p>通俗来讲，<strong>可重入锁就是一证通</strong>。</p>
<p><img src="http://p9.pstatp.com/large/pgc-image/80acb55db12e4d959f79f001db81407a" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>只需一个证就可以通过所有<strong>相同</strong>关卡：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/237fd4c8032742e6abe2427e72b38d2b" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>不可重入锁就是：<strong>即使每个关卡相同，你也得再拿一个一摸一样的证件来</strong>：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/d435143f8bb14dc5842a7e89c35e47bd" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>如果把证件看作是同步锁，把关卡看作是同步域（即同步代码块/方法或显式锁锁定的代码），那么<strong>可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。</strong></p>
<p>可重入锁和不可重入锁下面都有例子演示，希望大家可以结合例子体会可重入锁与不可重入锁的区别与联系。</p>
<p>看了不可重入锁的动画，大家心想：这不有病吗？已经有证件了，后面还要证件。所以，可重入锁就成了隐式锁和显式锁的默认选项。</p>
<p>隐式锁（即synchronized关键字使用的锁）默认是可重入锁，显式锁（即Lock）也有ReentrantLock这样的可重入锁。</p>
<p>单词Reentrant就是<strong>重入</strong>的意思，ReentrantLock即<strong>可重入锁</strong>。</p>
<p>隐式锁，即synchronized关键字用的锁。在<a target="_blank" rel="noopener" href="https://www.toutiao.com/i6662379038067130891/?group_id=6662379038067130891">《“全栈2019”Java多线程第二十七章：Lock获取lock/释放unlock锁》</a>一章中有介绍过，感兴趣的小伙伴可以前去阅读。</p>
<h1 id="3-隐式锁可重入锁例子"><a href="#3-隐式锁可重入锁例子" class="headerlink" title="3.隐式锁可重入锁例子"></a><strong>3.隐式锁可重入锁例子</strong></h1><p>我们先来看看隐式锁的可重入锁的例子。</p>
<p>隐式锁的可重入锁的例子很简单，这里我们先写一个匿名内部类实现Runnable接口的对象：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/2e7aa766c83640499a73797dd4484eec" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>先不着急把run()方法写好，先来把线程创建好。</p>
<p><strong>需要锁的地方一定是多个线程，但是这里我们只需1个线程即可，因为只要演示锁可重入即可，不需要多个线程去竞争锁，所以这里创建1个线程</strong>，并把runnable对象传递给线程：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/013b719324d7424ebd8fd75da22890d6" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>紧接着，我们启动线程的代码也写了：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/739c627090684d8695b43b1167a56c71" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>接下来，我们来完善run()方法内部。</p>
<p>在run()方法内部需要做的是，同步调用同步，即同步代码块/方法内部执行同步代码块/方法。我们先写一个外层同步代码块/方法：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/c3cc4f08b2ca439da783a3c6c2f9b29c" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>其次是在同步代码块/方法内部去执行另一个同步代码块/方法：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/d34382acd70f4b4a939b9f76be212695" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>好了，例子写完了，运行程序，执行结果：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/f1274c4b72ee44189e6058eb2929bd66" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>从运行结果来看，符合预期。</p>
<p>为什么说符合预期？</p>
<p>因为只要同步递归调用不发生死锁就是可重入锁，在上例中，外层同步代码块嵌套内层同步代码块，满足同步递归调用，所以说隐式锁默认就是可重入锁。</p>
<h1 id="4-显式锁可重入锁例子"><a href="#4-显式锁可重入锁例子" class="headerlink" title="4.显式锁可重入锁例子"></a><strong>4.显式锁可重入锁例子</strong></h1><p>显式锁即Lock。在上一章<a target="_blank" rel="noopener" href="https://www.toutiao.com/i6662379038067130891/?group_id=6662379038067130891">《“全栈2019”Java多线程第二十七章：Lock获取lock/释放unlock锁》</a>中也有介绍过，感兴趣的小伙伴可以前去阅读。</p>
<p>下面我们就来用显式锁改写上一小节例子。</p>
<p>首先，我们创建出显式锁对象：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/b1bffc9b28d94947a3af4bcb8d0160ee" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>其次，我们将外层同步代码块开始的地方换成lock.lock()，结束的地方换成lock.unlock()。即这两个地方：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/a176f986527d4388b2b2d063adb98c90" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>换完之后的样子：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/c20fb114ad2c4eb495f13dcbccfc3241" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>然后是将内层同步代码块开始的地方换成lock.lock()，结束的地方换成lock.unlock()。即这两个地方：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/549cd2ec4d1c4dfda9186df90a310dd2" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>换完之后的样子：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/a01e70d7eb124255be7f0fd821b2eeb4" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>好了，例子用显式锁改写完成。</p>
<p>接下来运行程序，观察执行结果：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/610c71e757244c1e833be3f12fd679d8" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>从运行结果来看，符合预期。</p>
<p>为什么说符合预期？</p>
<p>因为我们例子经过显式锁改写之后没有发生死锁，所以显式锁默认的也是可重入锁。</p>
<p>另外，该例子不光没有产生死锁，而且还<strong>更加直观的展现了可重入锁获取锁释放锁的流程</strong>。</p>
<h1 id="5-可重入锁的工作原理"><a href="#5-可重入锁的工作原理" class="headerlink" title="5.可重入锁的工作原理"></a>5.可重入锁的工作原理</h1><p><strong>可重入锁的工作原理很简单，就是用一个计数器来记录锁被获取的次数，获取锁一次计数器+1，释放锁一次计数器-1，当计数器为0时，表示锁可用。</strong></p>
<p>我们简单的来模拟出这个工作原理。</p>
<p>先定义一个计数器变量：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/e3018b9a2db046b4beb964d17d002950" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>然后，在获取同步锁的地方让计数器+1，并输出该锁被获取的次数：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/4db27bd51bb54bc4b6a7e7d45dad057f" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>接着，在释放锁的地方让计数器-1，并输出该锁被获取的次数：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/c8239c9f4b6b431691d9e8a5db6c641f" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>同理，在内层同步代码块也这么做：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/3930b2ea4e654a68ba42a0f9f3ab230a" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>例子书写完毕，运行程序，执行结果：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/68c4778ed8a246159024da3225efb6bf" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>从运行结果来看，符合预期。</p>
<p><strong>这里需要注意的是，我们同步域需要的锁一定要是同一把锁</strong>。</p>
<h1 id="6-不可重入锁例子"><a href="#6-不可重入锁例子" class="headerlink" title="6.不可重入锁例子"></a><strong>6.不可重入锁例子</strong></h1><p>再看一遍不可重入锁的动画：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/e49f1553174c42318820d7bea46f43c7" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>可以看出不可重入锁是每一个同步域需要的锁即使一样，也要你重新获取锁。现有阶段的锁默认都是可重入锁。所以我们得<strong>自己造一把不可重入锁</strong>。</p>
<p>首先，定义一个不可重入锁NotReentrantLock类：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/9f3c47a7545b4f0cbf9a5b90039ecdab" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>然后，实现Lock接口：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/ec0b6e1df8774840a1908a474525f415" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>接着，我们需要着重实现两个方法即可，一个lock()方法：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/ca46549ac3014663bf577eec87f3de82" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>还有一个unlock()方法：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/b0b41c7d879e446db65cc6afc0370bab" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>怎么实现lock()方法呢？</p>
<p>根据不可重入锁的动画和定义来看，只需将锁和一个线程绑定即可。</p>
<p>于是，我们在类中定义一个Thread类型的变量，用于绑定线程：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/b3291a95e61e4ad3ae5f597ca84702ae" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>紧接着，我们在lock()方法中记录当前来获取锁的线程：</p>
<p><img src="http://p9.pstatp.com/large/pgc-image/3e21c9c00dae476082b1ecbfde3e4c1b" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>于是，线程绑定工作就做完了。</p>
<p><strong>如果该线程已经拿到锁之后，还要再获取锁时，就给它wait，即不可重入</strong>：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/3c3d164e8406495991a9fcdd1bc7599c" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>lock()方法实现完毕。</p>
<p>那unlock()方法怎么实现呢？</p>
<p><strong>如果当前线程为绑定线程时，我们将绑定线程变量thread置空即可</strong>。</p>
<p>先获取当前线程：</p>
<p><img src="http://p9.pstatp.com/large/pgc-image/0828457f51ec4b869ae735ea2a169291" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>如果当前线程不为绑定线程，则使当前线程等待：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/449d65c749ba4759bbec0ab5bdca4bb7" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>如果当前线程为绑定线程，则将绑定线程变量置空：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/81a312713b4e46be8f38a99d73d097da" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>最后唤醒所有等待该锁的线程：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/11728799ed0b460abc842ba551cb6399" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>至此，不可重入锁写完了。</p>
<p>下面，来用用自定义的不可重入锁。</p>
<p>还是上一小节的例子，只不过将ReentrantLock对象改为NotReentrantLock对象：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/7ca21ffbf82d4a69b7e913fcdc74cc20" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>例子改写完毕，运行程序，执行结果：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/e6311cd254304df89cd67b57956c34d3" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>从运行结果来看，符合预期。</p>
<p>外层同步域已经拿到锁了，它不能连续再拿第二次锁：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/dd7e149a015e49e2b19ac7f66b7b7b11" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>接下来，外层同步域执行到内层同步域：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/4a907303dbac4183b78d0a200f02498d" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>此时内层同步域也需要和外层同步域一样的锁，于是就去执行lock.lock()方法，当发生当前线程就是绑定线程时，就wait了：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/4977cad59cb14a09b3deb043ed939fb7" alt="“全栈2019”Java多线程第二十九章：可重入锁与不可重入锁详解"></p>
<p>于是，程序就停止不动。</p>
<h1 id="7-不可重入锁别名"><a href="#7-不可重入锁别名" class="headerlink" title="7.不可重入锁别名"></a>7.不可重入锁别名</h1><p>不可重入锁也叫<strong>自旋锁</strong>。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><ul>
<li>可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。</li>
<li>隐式锁（即synchronized关键字使用的锁）默认是可重入锁，显式锁（即Lock）也有ReentrantLock这样的可重入锁。</li>
<li>可重入锁的工作原理很简单，就是用一个计数器来记录锁被获取的次数，获取锁一次计数器+1，释放锁一次计数器-1，当计数器为0时，表示锁可用。</li>
<li>不可重入锁也叫自旋锁。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/11/27/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/27/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">volatile关键字解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-27 14:35:00" itemprop="dateCreated datePublished" datetime="2020-11-27T14:35:00+08:00">2020-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:47:28" itemprop="dateModified" datetime="2022-09-22T22:47:28+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>作者：Matrix海子<br>出处：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/">http://www.cnblogs.com/dolphin0520/</a></p>
</blockquote>
<p>Java并发编程：volatile关键字解析</p>
<p>　　 volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p>
<p>　　volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p>
<p>　　以下是本文的目录大纲：</p>
<p>　　一.内存模型的相关概念</p>
<p>　　二.并发编程中的三个概念</p>
<p>　　三.Java内存模型</p>
<p>　　四..深入剖析volatile关键字</p>
<p>　　五.使用volatile关键字的场景</p>
<p>　　若有不正之处请多多谅解，并欢迎批评指正。</p>
<p>　　请尊重作者劳动成果，转载请标明原文链接：</p>
<p>　　<a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3920373.html">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
<h2 id="一-内存模型的相关概念"><a href="#一-内存模型的相关概念" class="headerlink" title="一.内存模型的相关概念"></a>一.内存模型的相关概念</h2><p>　　大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<p>　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + 1;</span><br></pre></td></tr></table></figure>

<p> 　当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p>　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>
<p>　　1）通过在总线加LOCK#锁的方式</p>
<p>　　2）通过缓存一致性协议</p>
<p>　　这2种方式都是硬件层面上提供的方式。</p>
<p>　　在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p><img src="https://images0.cnblogs.com/blog/288799/201408/212219343783699.jpg" alt="img"></p>
<h2 id="二-并发编程中的三个概念"><a href="#二-并发编程中的三个概念" class="headerlink" title="二.并发编程中的三个概念"></a>二.并发编程中的三个概念</h2><p>　　在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>
<p><strong>1.原子性</strong></p>
<p>　　原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>　　一个很经典的例子就是银行账户转账问题：</p>
<p>　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>　　所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>　　同样地反映到并发编程中会出现什么结果呢？</p>
<p>　　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p> 　假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>
<p>　　那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<p><strong>2.可见性</strong></p>
<p>　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>　　举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<p> 　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>　　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<p><strong>3.有序性</strong></p>
<p>　　有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;              </span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="literal">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>

<p> 　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//语句1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span>;    <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></span><br><span class="line">r = a*a;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p> 　这段代码有4个语句，那么可能的一个执行顺序是：</p>
<p>　　<img src="https://images0.cnblogs.com/blog/288799/201408/212305263939989.jpg" alt="img"></p>
<p>　　</p>
<p>　　那么可不可能是这个执行顺序呢： 语句2  语句1  语句4  语句3</p>
<p>　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>　　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="literal">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p> 　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p> 　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>　　也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h2 id="三-Java内存模型"><a href="#三-Java内存模型" class="headerlink" title="三.Java内存模型"></a>三.Java内存模型</h2><p>　　在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>　　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>　　举个简单的例子：在java中，执行下面这个语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = 10;</span><br></pre></td></tr></table></figure>

<p> 　执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>
<p>　　那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<p><strong>1.原子性</strong></p>
<p>　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>　　请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//语句1</span></span><br><span class="line">y = x;         <span class="comment">//语句2</span></span><br><span class="line">x++;           <span class="comment">//语句3</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p> 　咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p> 　所以上面4个语句只有语句1的操作具备原子性。</p>
<p>　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>　　不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<p><strong>2.可见性</strong></p>
<p>　　对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>　　而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<p><strong>3.有序性</strong></p>
<p>　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>　　下面就来具体介绍下happens-before原则（先行发生原则）：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>
<p>　　这8条原则摘自《深入理解Java虚拟机》。</p>
<p>　　这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>　　下面我们来解释一下前4条规则：</p>
<p>　　对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>　　第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>　　第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>　　第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h2 id="四-深入剖析volatile关键字"><a href="#四-深入剖析volatile关键字" class="headerlink" title="四.深入剖析volatile关键字"></a>四.深入剖析volatile关键字</h2><p>　　在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>
<p><strong>1.volatile关键字的两层语义</strong></p>
<p>　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>　　2）禁止进行指令重排序。</p>
<p>　　先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p> 　这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>　　但是用volatile修饰之后就变得不一样了：</p>
<p>　　第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>　　那么线程1读取到的就是最新的正确的值。</p>
<p><strong>2.volatile保证原子性吗？</strong></p>
<p>　　从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>
<p>　　下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>　　假如某个时刻变量inc的值为10，</p>
<p>　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>　　那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>　　把上面的代码改成以下任何一种都可以达到效果：</p>
<p>　　采用synchronized：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>　　采用Lock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inc++;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　采用AtomicInteger：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">AtomicInteger</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>　　在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<p><strong>3.volatile能保证有序性吗？</strong></p>
<p>　　在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>　　volatile关键字禁止指令重排序有两层意思：</p>
<p>　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
<p>　　可能上面说的比较绕，举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量</span></span><br><span class="line"><span class="comment">//flag为volatile变量</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></span><br><span class="line">flag = <span class="literal">true</span>;  <span class="comment">//语句3</span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure>

<p> 　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>　　那么我们回到前面举的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="literal">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p> 　前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<p><strong>4.volatile的原理和实现机制</strong></p>
<p>　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>　　下面这段话摘自《深入理解Java虚拟机》：</p>
<p>　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>　　2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<h2 id="五-使用volatile关键字的场景"><a href="#五-使用volatile关键字的场景" class="headerlink" title="五.使用volatile关键字的场景"></a>五.使用volatile关键字的场景</h2><p>　　synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>　　1）对变量的写操作不依赖于当前值</p>
<p>　　2）该变量没有包含在具有其他变量的不变式中</p>
<p>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>　　下面列举几个Java中使用volatile的几个场景。</p>
<p><strong>1.状态标记量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">()</span> &#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">inited</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = <span class="literal">true</span>;            </span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p><strong>2.double check</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　至于为何需要这么写请参考：</p>
<p>　　《Java 中的双重检查（Double-Check）》<a target="_blank" rel="noopener" href="http://blog.csdn.net/dl88250/article/details/5439024">http://blog.csdn.net/dl88250/article/details/5439024</a></p>
<p>　　和<a target="_blank" rel="noopener" href="http://www.iteye.com/topic/652440">http://www.iteye.com/topic/652440</a></p>
<p>　　参考资料：</p>
<p>　　《Java编程思想》</p>
<p>　　《深入理解Java虚拟机》</p>
<p>　　<a target="_blank" rel="noopener" href="http://jiangzhengjun.iteye.com/blog/652532">http://jiangzhengjun.iteye.com/blog/652532</a></p>
<p>　　<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html">http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html</a></p>
<p>　　<a target="_blank" rel="noopener" href="http://ifeve.com/volatile/">http://ifeve.com/volatile/</a></p>
<p>　　<a target="_blank" rel="noopener" href="http://blog.csdn.net/ccit0519/article/details/11241403">http://blog.csdn.net/ccit0519/article/details/11241403</a></p>
<p>　　<a target="_blank" rel="noopener" href="http://blog.csdn.net/ns_code/article/details/17101369">http://blog.csdn.net/ns_code/article/details/17101369</a></p>
<p>　　<a target="_blank" rel="noopener" href="http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html">http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html</a></p>
<p>　　<a target="_blank" rel="noopener" href="http://www.cppblog.com/elva/archive/2011/01/21/139019.html">http://www.cppblog.com/elva/archive/2011/01/21/139019.html</a></p>
<p>　　<a target="_blank" rel="noopener" href="http://ifeve.com/volatile-array-visiblity/">http://ifeve.com/volatile-array-visiblity/</a></p>
<p>　　<a target="_blank" rel="noopener" href="http://www.bdqn.cn/news/201312/12579.shtml">http://www.bdqn.cn/news/201312/12579.shtml</a></p>
<p>　　<a target="_blank" rel="noopener" href="http://exploer.blog.51cto.com/7123589/1193399">http://exploer.blog.51cto.com/7123589/1193399</a></p>
<p>　　<a target="_blank" rel="noopener" href="http://www.cnblogs.com/Mainz/p/3556430.html">http://www.cnblogs.com/Mainz/p/3556430.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/11/27/%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9ACAS%EF%BC%88%E8%BD%AC%EF%BC%89-%E4%B9%90%E8%A7%82%E9%94%81cas%E8%BD%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/27/%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9ACAS%EF%BC%88%E8%BD%AC%EF%BC%89-%E4%B9%90%E8%A7%82%E9%94%81cas%E8%BD%AC/" class="post-title-link" itemprop="url">乐观锁：CAS（转）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-27 14:23:46" itemprop="dateCreated datePublished" datetime="2020-11-27T14:23:46+08:00">2020-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:48:16" itemprop="dateModified" datetime="2022-09-22T22:48:16+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文作者：xiao潇<br>原文连接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaobudian0381/article/details/91564648">https://blog.csdn.net/xiaobudian0381/article/details/91564648</a></p>
</blockquote>
<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>本文从 <strong>CAS实例</strong> –&gt; <strong>什么是UnSafe类</strong> –&gt; <strong>CAS底层</strong> –&gt;<strong>AtomicInteger.getAndIncrement() 进行分析</strong> –&gt;<strong>CAS缺点</strong> –&gt; <strong>什么是ABA问题</strong> –&gt;<strong>原子引用</strong> –&gt;<strong>如何解决ABA问题</strong> –&gt;<strong>时间戳原子引用</strong></p>
<h2 id="CAS实例"><a href="#CAS实例" class="headerlink" title="CAS实例"></a>CAS实例</h2><p>CAS：比较并交换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// true 100</span></span><br><span class="line">        System.out.println(integer.compareAndSet(<span class="number">5</span>, <span class="number">100</span>) +<span class="string">&quot; &quot;</span>+ integer.get());</span><br><span class="line">        integer.compareAndSet(<span class="number">5</span>,<span class="number">30</span>);</span><br><span class="line">        <span class="comment">//false 100</span></span><br><span class="line">        System.out.println(integer.compareAndSet(<span class="number">5</span>, <span class="number">30</span>) +<span class="string">&quot; &quot;</span>+ integer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是UnSafe类"><a href="#什么是UnSafe类" class="headerlink" title="什么是UnSafe类"></a>什么是UnSafe类</h2><p>UnSafe类是CAS的核心类，由于Java无法直接访问底层系统，所以要通过本地的native方法进行访问，UnSafe类就相当于一个后门，基于该类可以直接操作特定内存中的数据，其内部就像C的指针一样操作内存。观察UnSafe类的源码，可以看到UnSafe类都是native方法，也就是说Unsafe类都是直接调用操作系统底层资源执行任务。</p>
<h2 id="CAS底层"><a href="#CAS底层" class="headerlink" title="CAS底层"></a>CAS底层</h2><p><strong>java.util.concurrent</strong>完全建立在CAS之上，CAS有三个操作数，内存值V、旧的预期值A、要修改的值B，如果 V == A, 那么 V =B，返回true；否则什么都不做返回false。</p>
<ol>
<li>CAS 的全称 Compare-And-Swap，它是一条 CPU 并发</li>
<li>CAS 说白了就是使用真实值和期望值进行比较，如果相等的话，进行修改成功，否则修改失败。</li>
<li>在Java中 CAS 底层使用的就是自旋锁 + UnSafe类。</li>
</ol>
<p>CAS并发原语体现在Java语言就是UnSafe类中的各个方法，调用UnSafe类的CAS方法，JVM会帮我们实现出CAS的汇编指令，这是一种完全依赖于硬件的功能，通过它体现了原子性操作。CAS是系统原语，属于操作系统指令范畴，若干条指令组成，执行必须是连续的，并且执行过程中不会被中断，也就是说CAS是一种CPU的原子指令，不会造成所谓的数据不一致情况。</p>
<h2 id="AtomicInteger-getAndIncrement-进行分析"><a href="#AtomicInteger-getAndIncrement-进行分析" class="headerlink" title="AtomicInteger.getAndIncrement() 进行分析"></a>AtomicInteger.getAndIncrement() 进行分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>this是 AtomicInteger实例对象；</li>
<li>valueOffset是基于该实例对象的偏移量；</li>
<li>1是需要加的值<br>然后调用的是 UnSafe类 的 getAndAddInt方法。</li>
</ol>
<h3 id="UnSafe-的-getAndAddInt"><a href="#UnSafe-的-getAndAddInt" class="headerlink" title="UnSafe 的 getAndAddInt"></a>UnSafe 的 getAndAddInt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>var1 AtomicInteger 对象本身</li>
<li>var2 内存地址偏移量</li>
<li>var4 要进行加多少</li>
<li>var5 在通过var1 var2 找出了主物理内存上面真实的值 用当前该对象的值比较var5 如果相同更新var5 + var4 并返回true</li>
<li>如果不同，继续取值然后再比较，直至更新完成</li>
</ol>
<h2 id="CAS缺点？"><a href="#CAS缺点？" class="headerlink" title="CAS缺点？"></a>CAS缺点？</h2><ol>
<li>循环时间长开销大；<br>如果线程数比较多的话，CAS请求失败会一直循环下去，这样的话CPU带来的开销就比较大。</li>
<li>只能保证一个共享变量的原子操作；<br>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性。</li>
<li>会出现ABA问题。</li>
</ol>
<h2 id="什么是ABA问题"><a href="#什么是ABA问题" class="headerlink" title="什么是ABA问题"></a>什么是ABA问题</h2><p>举例说明：有两个人A、B，桌子上有一个耳机，然后A去拿耳机用，桌子上换成饼干，耳机用完，桌子上又换回了耳机。对于桌子而言状态变化：耳机 — 饼干 — 耳机。然后B同学去桌子拿耳机用，在B看来桌子上的耳机没有变化，但是过程中耳机已经被使用过了，这就是ABA问题。换句话说就是： 开头和结尾是一样的，中间的过程会发生变化。</p>
<h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p><strong>AtomicReference</strong> 一般的都是保证基本类型的原子性，对于一个类而言可以使用原子引用进行封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference&lt;User&gt; are = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>以上就完成了保证User类原子性。</p>
<h2 id="如何解决ABA问题"><a href="#如何解决ABA问题" class="headerlink" title="如何解决ABA问题"></a>如何解决ABA问题</h2><p>使用CAS+版本号进行解决，对一个数据如果修改了的话，那么版本号就进行+1，然后再循环比较的时候，不仅仅比较值再根据版本号就可以解决ABA问题。</p>
<h2 id="时间戳原子引用"><a href="#时间戳原子引用" class="headerlink" title="时间戳原子引用"></a>时间戳原子引用</h2><p>其中原有的原子性上面加入了版本号的概念：<br>使用案例：线程B修改值的时候，发现虽然内存中的值和预期的值一样，但是由于版本号已经发生了改变，所以修改失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的版本号为：&quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span> );</span><br><span class="line">            stampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span> );</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的版本号为：&quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(b); <span class="comment">// false</span></span><br><span class="line">            System.out.println(stampedReference.getReference()); <span class="comment">// 100</span></span><br><span class="line">            System.out.println(stampedReference.getStamp()); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/11/26/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81%E6%8B%86%E7%AE%B1%E7%9A%84%E6%97%B6%E9%97%B4%E6%B6%88%E8%80%97-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1%E7%9A%84%E6%97%B6%E9%97%B4%E6%B6%88%E8%80%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/26/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81%E6%8B%86%E7%AE%B1%E7%9A%84%E6%97%B6%E9%97%B4%E6%B6%88%E8%80%97-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1%E7%9A%84%E6%97%B6%E9%97%B4%E6%B6%88%E8%80%97/" class="post-title-link" itemprop="url">自动装箱、拆箱的时间消耗</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-26 14:00:24" itemprop="dateCreated datePublished" datetime="2020-11-26T14:00:24+08:00">2020-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:49:05" itemprop="dateModified" datetime="2022-09-22T22:49:05+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>装箱就是自动将基本数据类型转换为包装器类型:  比如 int-&gt; Integer<br>拆箱就是自动将包装器类型转换为基本数据类型:  比如  Integer -&gt; int</p>
</blockquote>
<h3 id="对比耗时"><a href="#对比耗时" class="headerlink" title="对比耗时"></a>对比耗时</h3><h4 id="1-使用自动装箱、拆箱"><a href="#1-使用自动装箱、拆箱" class="headerlink" title="1. 使用自动装箱、拆箱"></a>1. 使用自动装箱、拆箱</h4><p>用for循环，从1-1亿 进行累加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//包装类型</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">           sum += i;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;sum==&gt; &quot;</span> + sum);</span><br><span class="line">       <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;Test1 :take &quot;</span> + (end - start)/<span class="number">1000.0f</span> +  <span class="string">&quot; seconds&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>耗时<br>sum==&gt; 499999999500000000<br>Test1 :take 5.892 seconds</p>
<h4 id="2-不使用自动装箱、拆箱"><a href="#2-不使用自动装箱、拆箱" class="headerlink" title="2. 不使用自动装箱、拆箱"></a>2. 不使用自动装箱、拆箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//普通类型</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">           sum += i;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;sum==&gt; &quot;</span> + sum);</span><br><span class="line">       <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;Test1 :take &quot;</span> + (end - start)/<span class="number">1000.0f</span> +  <span class="string">&quot; seconds&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>耗时<br>sum==&gt; 499999999500000000<br>Test1 :take 0.74 seconds</p>
<h4 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a>3. 结论</h4><ul>
<li><strong>频繁的</strong>自动装箱、拆箱会耗费大量的时间</li>
<li>在执行大量运算的时候，尽量使用普通类型进行运算，在结果处使用包装类型即可</li>
</ul>
<h3 id="原因探究"><a href="#原因探究" class="headerlink" title="原因探究"></a>原因探究</h3><h4 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h4><p>比如在执行Long l = 100 的时候，实际上执行了 Long.valueOf（100）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//valueOf源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">      <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">          <span class="keyword">return</span> LongCache.cache[(<span class="type">int</span>)l + offset];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Long</span>(l);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>也就是说在 -128~127之间是从缓存里取出的。一旦超出了这个范围就会创建一个Long的对象。所以装箱的过程会增加内存的消耗，影响性能。</p>
<p>这个创建对象的过程就是耗费时间的原因所在。执行上面的代码不断创建了Long的对象，自然执行之间会久一些。</p>
<h4 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h4><p>Long obj= 100;<br>long l = obj;(此处自动拆箱）<br>实际上调用了 obj.longValue();方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"> <span class="comment">/**	</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> Long&#125; as a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> long&#125; value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">longValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="undertow"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">undertow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">undertow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
