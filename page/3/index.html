<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.under2.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="undertow &#39;s blog">
<meta property="og:url" content="http://blog.under2.cn/page/3/index.html">
<meta property="og:site_name" content="undertow &#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="undertow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.under2.cn/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>undertow 's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="undertow 's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <!-- 自定义右上角 github -->
    <a target="_blank" rel="noopener" href="https://github.com/under-tow" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <!-- 自定义右上角 github -->

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">undertow 's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2021/01/23/Typora%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87-typora%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/23/Typora%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87-typora%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/" class="post-title-link" itemprop="url">Typora自动上传图片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-23 01:05:00" itemprop="dateCreated datePublished" datetime="2021-01-23T01:05:00+08:00">2021-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:47:20" itemprop="dateModified" datetime="2022-09-22T22:47:20+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Typora是我们比较熟悉的编辑器了，但是默认图片是保存在本地的。<br>当我们复制文件到其他电脑上时，就发现图片都不见了。<br>那如何把我们的图片自动上传到云端呢？</p>
</blockquote>
<p>我使用的是这个开源项目：<a target="_blank" rel="noopener" href="https://github.com/Thobian/typora-plugins-win-img">https://github.com/Thobian/typora-plugins-win-img</a></p>
<p>它支持</p>
<ul>
<li>自建的服务器</li>
<li>腾讯云的COS</li>
<li>阿里云OSS·</li>
<li>七牛云</li>
<li>github 默认上传到github</li>
<li>gitee码云</li>
</ul>
<hr>
<h3 id="安装教程环境说明："><a href="#安装教程环境说明：" class="headerlink" title="安装教程环境说明："></a><strong>安装教程环境说明：</strong></h3><ul>
<li>typora版本：0.9.68 (Windows x86) （<a target="_blank" rel="noopener" href="https://typora.io/windows/typora-update-ia32-0320.exe">去下载</a>）</li>
<li>typora默认安装目录：<code>C:\Program Files (x86)\Typora</code> ，可以安装在其他目录</li>
</ul>
<h3 id="如何安装？"><a href="#如何安装？" class="headerlink" title="如何安装？"></a>如何安装？</h3><p>首先下载刚刚的开源项目，解压</p>
<p><strong>然后只需三步</strong></p>
<ul>
<li>粘贴<code>plugins</code>文件</li>
<li>修改你原来的<code>window.html</code>文件</li>
<li>修改<code>plugins</code>中的<code>upload.js</code>文件</li>
</ul>
<p>一步一步来：</p>
<p>1 先把<code>plugins</code>文件复制到你的安装目录里的<code>Typora\resources\app</code></p>
<p><img src="https://gitee.com/hopestation/typora/raw/master/images/202101/23/003256-842782.png" alt="image-20210123003225181"></p>
<p>2 修改<strong>你自己的</strong><code>window.html</code>【注意不是替换，相当于下载的压缩包里的<code>window.html</code>没啥用..】</p>
<p>打开，然后搜索</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./app/window/frame.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在后面加上这一句话就好了【目的是为了引入upload.js文件】</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./plugins/image/upload.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3 修改<code>upload.js</code>文件 【按照说明填写就好了】</p>
<p><img src="https://gitee.com/hopestation/typora/raw/master/images/202101/23/004528-822676.png" alt="image-20210123004528592"></p>
<p>根据你的需求填写<code>target</code></p>
<p><img src="https://gitee.com/hopestation/typora/raw/master/images/202101/23/005027-266670.png" alt="image-20210123005026542"></p>
<p>然后修改下面的JS就好了！【我是用的码云，你们根据需求修改对应的js】</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ！！！注意当图片大于1M时， gitee 必须登录后才能查看！！！</span></span><br><span class="line">$.image.<span class="title function_">init</span>(&#123;</span><br><span class="line">    <span class="attr">target</span>:<span class="string">&#x27;gitee&#x27;</span>,</span><br><span class="line">    <span class="attr">gitee</span>: &#123;</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&quot;From:https://github.com/Thobian&quot;</span>,     <span class="comment">// 必须参数,提交消息（默认为：add image）</span></span><br><span class="line">            <span class="attr">branch</span>: <span class="string">&quot;master&quot;</span>,                               <span class="comment">// 要提交到的分支（默认为：master）</span></span><br><span class="line">            <span class="attr">token</span>: <span class="string">&#x27;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#x27;</span>,   <span class="comment">// 码云token申请地址 https://gitee.com/profile/personal_access_tokens</span></span><br><span class="line">            <span class="attr">userName</span>: <span class="string">&#x27;userName&#x27;</span>,                           <span class="comment">// 用户名 比如你的gitee个人主页地址是：https://gitee.com/thobian ，那userName就是：thobian</span></span><br><span class="line">            <span class="attr">repositorie</span>: <span class="string">&#x27;repositorie&#x27;</span>,                     <span class="comment">// 仓库名 比如你的gitee图片仓库地址是：https://gitee.com/thobian/typora，那么repositorie就是 typora</span></span><br><span class="line">            <span class="title class_">Folder</span>: <span class="string">&#x27;image&#x27;</span>,                                <span class="comment">// 可以把上传的图片都放到这个指定的文件夹下</span></span><br><span class="line">            <span class="title class_">BucketDomain</span>: <span class="string">&#x27;https://gitee.com/api/v5/repos/&#x27;</span>,<span class="comment">// 这个是不用变的，直接copy就好</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>比如Gitee，你可以专门建一个仓库来保存图片，注意仓库需要是<strong>公开</strong>的</p>
<p>假如仓库是私密的，会出现typora上传成功，但是无法查看的情况。</p>
</blockquote>
<p>最后重启Typora，粘贴一个图片试试，搞定！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2021/01/14/Redis%E8%A1%A5%E5%85%85%EF%BC%88%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%89-redis%E8%A1%A5%E5%85%85%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/14/Redis%E8%A1%A5%E5%85%85%EF%BC%88%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%89-redis%E8%A1%A5%E5%85%85%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">Redis补充（内存淘汰策略）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-14 23:05:46" itemprop="dateCreated datePublished" datetime="2021-01-14T23:05:46+08:00">2021-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:46:53" itemprop="dateModified" datetime="2022-09-22T22:46:53+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>redis淘汰策略<br>这里面其实就只是分了两种：</p>
<ol>
<li>包含过期的key</li>
<li>所有的key</li>
</ol>
<p>每种key都有这么几种策略：<br>lru：最近最少使用原则<br>lfu：使用频率最低原则<br>ttl：如果设置过期时间，则从已经过期的时间中挑选要过期的<br>random：随机淘汰已经过期的<br>（1）volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。<br>（2）volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。<br>（3）volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。<br>（4）volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。<br>（5）allkeys-lru：从数据集中挑选最近最少使用的数据淘汰<br>（6）allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。<br>（7）allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br>（8） no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。</p>
<p>这八种大体上可以分为4中，lru、lfu、random、ttl</p>
<p>这也是再配置文件里进行配置的，redis.conf相应内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span></span><br><span class="line"><span class="comment"># is reached. You can select one from the following behaviors:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span></span><br><span class="line"><span class="comment"># allkeys-lru -&gt; Evict any key using approximated LRU.</span></span><br><span class="line"><span class="comment"># volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.</span></span><br><span class="line"><span class="comment"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span></span><br><span class="line"><span class="comment"># volatile-random -&gt; Remove a random key having an expire set.</span></span><br><span class="line"><span class="comment"># allkeys-random -&gt; Remove a random key, any key.</span></span><br><span class="line"><span class="comment"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span></span><br><span class="line"><span class="comment"># noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LRU means Least Recently Used</span></span><br><span class="line"><span class="comment"># LFU means Least Frequently Used</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Both LRU, LFU and volatile-ttl are implemented using approximated</span></span><br><span class="line"><span class="comment"># randomized algorithms.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note: with any of the above policies, Redis will return an error on write</span></span><br><span class="line"><span class="comment">#       operations, when there are no suitable keys for eviction.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       At the date of writing these commands are: set setnx setex append</span></span><br><span class="line"><span class="comment">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span></span><br><span class="line"><span class="comment">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span></span><br><span class="line"><span class="comment">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span></span><br><span class="line"><span class="comment">#       getset mset msetnx exec sort</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is:</span></span><br><span class="line"><span class="comment">#禁止驱逐数据，默认策略</span></span><br><span class="line"><span class="comment"># maxmemory-policy noeviction</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2021/01/14/Redis%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95-redis%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/14/Redis%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95-redis%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95/" class="post-title-link" itemprop="url">Redis系列目录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-14 23:01:33" itemprop="dateCreated datePublished" datetime="2021-01-14T23:01:33+08:00">2021-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:46:58" itemprop="dateModified" datetime="2022-09-22T22:46:58+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="Redis（一）概念和安装"><a href="#Redis（一）概念和安装" class="headerlink" title="Redis（一）概念和安装"></a><span style="    font-size: inherit;  line-height: inherit;display: inline-block;  font-weight: normal; background: rgb(128, 128, 128); color: rgb(255, 255, 255);  padding: 3px 10px 1px;border-top-right-radius: 3px;   border-top-left-radius: 3px;  margin-right: 3px;" >Redis（一）概念和安装</span></h2><div style="height:3px;background:rgb(128, 128, 128);margin-top:-25px;padding-bottom:3px"></div><div style="margin-bottom:10px"></div>

<p>此篇<a target="_blank" rel="noopener" href="http://hopestation.top/archives/redis1">文章</a>主要介绍了：</p>
<ul>
<li>什么是Redis，为什么要使用Redis</li>
<li>Windows系统和Linux系统下的Redis的安装</li>
<li>性能测试</li>
</ul>
<h2 id="Redis（二）操作、数据类型"><a href="#Redis（二）操作、数据类型" class="headerlink" title="Redis（二）操作、数据类型"></a><span style="    font-size: inherit;  line-height: inherit;display: inline-block;  font-weight: normal; background: rgb(128, 128, 128); color: rgb(255, 255, 255);  padding: 3px 10px 1px;border-top-right-radius: 3px;   border-top-left-radius: 3px;  margin-right: 3px;" >Redis（二）操作、数据类型</span></h2><div style="height:3px;background:rgb(128, 128, 128);margin-top:-25px;padding-bottom:3px"></div><div style="margin-bottom:10px"></div>

<p>此篇<a target="_blank" rel="noopener" href="http://hopestation.top/archives/redis2">文章</a>主要介绍了：</p>
<ul>
<li>Redis是单线程的</li>
<li>常用数据类型的详细介绍</li>
</ul>
<h2 id="Redis（三）事务"><a href="#Redis（三）事务" class="headerlink" title="Redis（三）事务"></a><span style="    font-size: inherit;  line-height: inherit;display: inline-block;  font-weight: normal; background: rgb(128, 128, 128); color: rgb(255, 255, 255);  padding: 3px 10px 1px;border-top-right-radius: 3px;   border-top-left-radius: 3px;  margin-right: 3px;" >Redis（三）事务</span></h2><div style="height:3px;background:rgb(128, 128, 128);margin-top:-25px;padding-bottom:3px"></div><div style="margin-bottom:10px"></div>

<p>此篇<a target="_blank" rel="noopener" href="http://hopestation.top/archives/redis3">文章</a>主要介绍了：</p>
<ul>
<li>Redis事务的概念</li>
<li>如何实一个Redis事务</li>
</ul>
<h2 id="Redis（四）实现乐观锁"><a href="#Redis（四）实现乐观锁" class="headerlink" title="Redis（四）实现乐观锁"></a><span style="    font-size: inherit;  line-height: inherit;display: inline-block;  font-weight: normal; background: rgb(128, 128, 128); color: rgb(255, 255, 255);  padding: 3px 10px 1px;border-top-right-radius: 3px;   border-top-left-radius: 3px;  margin-right: 3px;" >Redis（四）实现乐观锁</span></h2><div style="height:3px;background:rgb(128, 128, 128);margin-top:-25px;padding-bottom:3px"></div><div style="margin-bottom:10px"></div>

<p>此篇<a target="_blank" rel="noopener" href="http://hopestation.top/archives/redis4">文章</a>主要介绍了：</p>
<ul>
<li>为什么要用锁</li>
<li>什么是乐观锁、悲观锁</li>
<li>Redis如何实现乐观锁</li>
</ul>
<h2 id="Redis（五）Jedis"><a href="#Redis（五）Jedis" class="headerlink" title="Redis（五）Jedis"></a><span style="    font-size: inherit;  line-height: inherit;display: inline-block;  font-weight: normal; background: rgb(128, 128, 128); color: rgb(255, 255, 255);  padding: 3px 10px 1px;border-top-right-radius: 3px;   border-top-left-radius: 3px;  margin-right: 3px;" >Redis（五）Jedis</span></h2><div style="height:3px;background:rgb(128, 128, 128);margin-top:-25px;padding-bottom:3px"></div><div style="margin-bottom:10px"></div>

<p>此篇<a target="_blank" rel="noopener" href="http://hopestation.top/archives/redis5">文章</a>主要介绍了：</p>
<ul>
<li>什么是Jedis</li>
<li>与Java结合使用Jedis来操作Redis数据库</li>
</ul>
<h2 id="Redis（六）SpringBoot整合"><a href="#Redis（六）SpringBoot整合" class="headerlink" title="Redis（六）SpringBoot整合"></a><span style="    font-size: inherit;  line-height: inherit;display: inline-block;  font-weight: normal; background: rgb(128, 128, 128); color: rgb(255, 255, 255);  padding: 3px 10px 1px;border-top-right-radius: 3px;   border-top-left-radius: 3px;  margin-right: 3px;" >Redis（六）SpringBoot整合</span></h2><div style="height:3px;background:rgb(128, 128, 128);margin-top:-25px;padding-bottom:3px"></div><div style="margin-bottom:10px"></div>

<p>此篇<a target="_blank" rel="noopener" href="http://hopestation.top/archives/redis6">文章</a>主要介绍了：</p>
<ul>
<li>SpringBoot整合Redis</li>
<li>RestTamplate工具类</li>
</ul>
<h2 id="Redis（七）conf配置文件"><a href="#Redis（七）conf配置文件" class="headerlink" title="Redis（七）conf配置文件"></a><span style="    font-size: inherit;  line-height: inherit;display: inline-block;  font-weight: normal; background: rgb(128, 128, 128); color: rgb(255, 255, 255);  padding: 3px 10px 1px;border-top-right-radius: 3px;   border-top-left-radius: 3px;  margin-right: 3px;" >Redis（七）conf配置文件</span></h2><div style="height:3px;background:rgb(128, 128, 128);margin-top:-25px;padding-bottom:3px"></div><div style="margin-bottom:10px"></div>

<p>此篇<a target="_blank" rel="noopener" href="http://hopestation.top/archives/redis7">文章</a>主要介绍了：</p>
<ul>
<li>Redis配置文件的参数</li>
</ul>
<h2 id="Redis（八）持久化"><a href="#Redis（八）持久化" class="headerlink" title="Redis（八）持久化"></a><span style="    font-size: inherit;  line-height: inherit;display: inline-block;  font-weight: normal; background: rgb(128, 128, 128); color: rgb(255, 255, 255);  padding: 3px 10px 1px;border-top-right-radius: 3px;   border-top-left-radius: 3px;  margin-right: 3px;" >Redis（八）持久化</span></h2><div style="height:3px;background:rgb(128, 128, 128);margin-top:-25px;padding-bottom:3px"></div><div style="margin-bottom:10px"></div>

<p>此篇<a target="_blank" rel="noopener" href="http://hopestation.top/archives/redis8">文章</a>主要介绍了：</p>
<ul>
<li>AOF</li>
<li>RDB</li>
<li>实际操作</li>
</ul>
<h2 id="Redis（九）主从复制"><a href="#Redis（九）主从复制" class="headerlink" title="Redis（九）主从复制"></a><span style="    font-size: inherit;  line-height: inherit;display: inline-block;  font-weight: normal; background: rgb(128, 128, 128); color: rgb(255, 255, 255);  padding: 3px 10px 1px;border-top-right-radius: 3px;   border-top-left-radius: 3px;  margin-right: 3px;" >Redis（九）主从复制</span></h2><div style="height:3px;background:rgb(128, 128, 128);margin-top:-25px;padding-bottom:3px"></div><div style="margin-bottom:10px"></div>

<p>此篇<a target="_blank" rel="noopener" href="http://hopestation.top/archives/redis9">文章</a>主要介绍了：</p>
<ul>
<li>为什么需要主从复制</li>
<li>概念</li>
<li>如何搭建主从复制</li>
<li>宕机后的情况</li>
</ul>
<h2 id="Redis（十）哨兵"><a href="#Redis（十）哨兵" class="headerlink" title="Redis（十）哨兵"></a><span style="    font-size: inherit;  line-height: inherit;display: inline-block;  font-weight: normal; background: rgb(128, 128, 128); color: rgb(255, 255, 255);  padding: 3px 10px 1px;border-top-right-radius: 3px;   border-top-left-radius: 3px;  margin-right: 3px;" >Redis（十）哨兵</span></h2><div style="height:3px;background:rgb(128, 128, 128);margin-top:-25px;padding-bottom:3px"></div><div style="margin-bottom:10px"></div>

<p>此篇<a target="_blank" rel="noopener" href="http://hopestation.top/archives/redis10">文章</a>主要介绍了：</p>
<ul>
<li>哨兵是什么</li>
<li>如何搭建哨兵模式</li>
</ul>
<h2 id="Redis（十一）缓存雪崩等问题"><a href="#Redis（十一）缓存雪崩等问题" class="headerlink" title="Redis（十一）缓存雪崩等问题"></a><span style="    font-size: inherit;  line-height: inherit;display: inline-block;  font-weight: normal; background: rgb(128, 128, 128); color: rgb(255, 255, 255);  padding: 3px 10px 1px;border-top-right-radius: 3px;   border-top-left-radius: 3px;  margin-right: 3px;" >Redis（十一）缓存雪崩等问题</span></h2><div style="height:3px;background:rgb(128, 128, 128);margin-top:-25px;padding-bottom:3px"></div><div style="margin-bottom:10px"></div>

<p>此篇<a target="_blank" rel="noopener" href="http://hopestation.top/archives/redis1">文章</a>主要介绍了：</p>
<ul>
<li>缓存击穿</li>
<li>缓存穿透</li>
<li>缓存雪崩</li>
</ul>
<h2 id="Redis补充"><a href="#Redis补充" class="headerlink" title="Redis补充"></a><span style="    font-size: inherit;  line-height: inherit;display: inline-block;  font-weight: normal; background: rgb(128, 128, 128); color: rgb(255, 255, 255);  padding: 3px 10px 1px;border-top-right-radius: 3px;   border-top-left-radius: 3px;  margin-right: 3px;" >Redis补充</span></h2><div style="height:3px;background:rgb(128, 128, 128);margin-top:-25px;padding-bottom:3px"></div><div style="margin-bottom:10px"></div>


<ul>
<li><a target="_blank" rel="noopener" href="https://hopestation.top/archives/redis-del">内存淘汰机制</a></li>
<li><a target="_blank" rel="noopener" href="https://hopestation.top/archives/redis-data-type">数据类型的使用场景</a></li>
</ul>
<hr>
<blockquote>
<p>Redis是自己根据B站的狂神说的视频为主线进行学习的，通过自己的理解、然后也参考了一些其他优秀的文章，最后记下笔记形成了这些文章。<br>如有描述不准确或不对的地方欢迎评论交流指出。<br>最后附上狂神说的视频链接，以表感谢：<br><a target="_blank" rel="noopener" href="https://space.bilibili.com/95256449">https://space.bilibili.com/95256449</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2021/01/14/MYSQL%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E8%BD%AC%EF%BC%89-mysql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%BD%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/14/MYSQL%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E8%BD%AC%EF%BC%89-mysql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%BD%AC/" class="post-title-link" itemprop="url">MYSQL执行过程（转）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-14 22:58:36" itemprop="dateCreated datePublished" datetime="2021-01-14T22:58:36+08:00">2021-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:45:51" itemprop="dateModified" datetime="2022-09-22T22:45:51+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MYSQL/" itemprop="url" rel="index"><span itemprop="name">MYSQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文出处：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_50666791/article/details/108475400">https://blog.csdn.net/weixin_50666791/article/details/108475400</a><br>也可以看看这篇文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wyq178/p/11576065.html">https://www.cnblogs.com/wyq178/p/11576065.html</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文基于MySQL5.7版本。</p>
<p>前面几篇MySQL系列的文章介绍了索引，事务和锁相关知识，那么今天就让我们来看看当我们执行一条select语句和一条update语句的时候,MySQL要经过哪些步骤，才能返回我们想要的数据。</p>
<h1 id="一条select语句的执行流程"><a href="#一条select语句的执行流程" class="headerlink" title="一条select语句的执行流程"></a>一条select语句的执行流程</h1><p>MySQL从大方向来说，可以分为 Server 层和存储引擎层。而Server层包括连接器、查询缓存、解析器、预处理器、优化器、执行器等，最后Server层再通过API接口形式调用对应的存储引擎层提供的接口。如下图所示(图片来源于《高性能MySQL》)：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2E1N2E4ZjQ5NzMxMzQ0MzBhMWUzYjBkMzM3NWMzYTIw?x-oss-process=image/format,png" alt="详解一条查询select语句和更新update语句的执行流程"></p>
<p>在这里插入图片描述</p>
<p>根据流程图，一条select查询大致经过以下六个步骤：<br>1、客户端发起一个请求时，首先会建立一个连接<br>2、服务端会检查缓存，如果命中则直接返回，否则继续之后后面步骤<br>3、服务器端根据收到的sql语句进行解析，然后对其进行词法分析，语法分析以及预处理<br>4、由优化器生成执行计划<br>5、调用存储引擎层API来执行查询<br>6、返回查询到的结果</p>
<p>查询流程也可以通过如下图表示(图片来源于丁奇MySQL45将)：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2IxZWUwZWViZmI5ODQ2OWY4OGRiMmU5NWZjZGRlYzA5?x-oss-process=image/format,png" alt="详解一条查询select语句和更新update语句的执行流程"></p>
<p>在这里插入图片描述</p>
<h1 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h1><p>第一步建立连接，这个很容易理解，需要特别指出的是MySQL服务端和客户端的通信方式采用的是<strong>半双工协议</strong>。</p>
<p>通信方式主要可以分为三种：单工，半双工，全双工，如下图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2Q3N2U1ODRmZDAzMjRhOWI5NzNkZWQxMWQ4MDE5ZGRm?x-oss-process=image/format,png" alt="详解一条查询select语句和更新update语句的执行流程"></p>
<p>在这里插入图片描述</p>
<ul>
<li>单工：通信的时候，数据只能单向传输。比如说遥控器，我们只能用遥控器来控制电视机，而不能用电视机来控制遥控器。</li>
<li>半双工：通信的时候，数据可以双向传输，但是同一时间只能有一台服务器在发送数据，当A给B发送数据的时候，那么B就不能给A发送数据，必须等到A发送结束之后，B才能给A发送数据。比如说对讲机。</li>
<li>全双工：通信的时候，数据可以双向传输，并且可以同时传输。比如说我们打电话或者用通信软件进行语音和视频通话等。</li>
</ul>
<p>半双工协议让MySQL通信简单快速，但是也在一定程度上限制了MySQL的性能，因为一旦从一端开始发送数据，另一端必须要接收完全部数据才能做出响应。所以说我们批量插入的时候尽量拆分成多次插入而不要一次插入太大数据，同样的查询语句最好也带上limit限制条数，避免一次返回过多数据。</p>
<p>MySQL单次传输数据包的大小可以通过参数max_allowed_packet控制,默认大小为4MB</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;max_allowed_packet&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzhmM2QxOTUyZTA2YzRjODlhNzM5ZjkwN2ZhZTNiNTQy?x-oss-process=image/format,png" alt="详解一条查询select语句和更新update语句的执行流程"></p>
<p>在这里插入图片描述</p>
<h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>连接上了之后，如果缓存是打开的，那么就会进入查询缓存阶段，可以通过如下命令查看缓存是否开启：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;query_cache_type&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2EyZjkzNzcwMTYxMDRmMDU5MTkxMzY2ODYwYzBmN2Zj?x-oss-process=image/format,png" alt="详解一条查询select语句和更新update语句的执行流程"></p>
<p>在这里插入图片描述</p>
<p>我们可以看到，缓存默认是关闭的。这是因为MySQL的缓存使用条件非常苛刻，是通过一个大小写敏感的哈希值去匹配的，这样就是说一条查询语句哪怕只是有一个空格不一致，都会导致无法使用缓存。而且一旦表里面有一行数据变动了，那么关于这种表的所有缓存都会失效。所以一般我们都是不建议使用缓存，MySQL最新的8.0版本已经将缓存模块去掉了。</p>
<h1 id="解析器和预处理器"><a href="#解析器和预处理器" class="headerlink" title="解析器和预处理器"></a>解析器和预处理器</h1><p>跳过了缓存模块之后，查询语句会进入解析器进行解析。</p>
<h1 id="词法解析和语法解析-Parser"><a href="#词法解析和语法解析-Parser" class="headerlink" title="词法解析和语法解析(Parser)"></a>词法解析和语法解析(Parser)</h1><p>这一步主要的工作就是检查sql语句的语法对不对，在这里，首先会把我们整个SQL语句打碎，比如：select name from test where id=1，就会被打散成select，name，from，test，where，id，=，1 这8个字符，并且能识别出关键字和非关键字，然后根据sql语句生成一个数据结构，也叫做解析树(select_lex)，如下图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2E5ODdmNzlhYTQ4NjQzNGFhZTlhNTU4YTViZTRmMDhk?x-oss-process=image/format,png" alt="详解一条查询select语句和更新update语句的执行流程"></p>
<p>在这里插入图片描述</p>
<h1 id="预处理器-Preprocessor"><a href="#预处理器-Preprocessor" class="headerlink" title="预处理器(Preprocessor)"></a>预处理器(Preprocessor)</h1><p>经过了前面的词法和语法解析，那么至少我们一条sql语句的语法格式是满足要求了，接下来我们还需要做什么呢？自然是检查表名，列名以及其他一些信息等是不是真实存在的，<strong>预处理就是做一个表名和字段名等相关信息合法性的检测</strong>。</p>
<h1 id="查询优化器-Query-Optimizer"><a href="#查询优化器-Query-Optimizer" class="headerlink" title="查询优化器(Query Optimizer)"></a>查询优化器(Query Optimizer)</h1><p>经过上面的步骤，到这里就得到了一句有效的sql语句了。而对一个查询语句，尤其是复杂的多表查询语句，我们可以有很多种执行方式，每种执行方式的效率也不一样，所以这时候就需要查询优化器去选择一种它认为最高效的执行方式。</p>
<p>查询优化器的目的就是根据解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划，MySQL 里面使用的是基于开销（cost）的优化器，哪种执行计划开销最小，就选择哪种。</p>
<p>我们可以通过变量Last_query_cost来查询开销：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show status like &#x27;Last_query_cost&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2E5MWQ2N2Y0NzdkMTRkOWJhMjY3NmFlMTM2ZTFjNGMz?x-oss-process=image/format,png" alt="详解一条查询select语句和更新update语句的执行流程"></p>
<p>在这里插入图片描述</p>
<p>上图中展示的结果就表示MySQL认为SELECT * FROM test 查询语句需要做至少2个数据页的随机查找才能完成上面的查询。<br>这个结果是通过一系列复杂的运算得到的，包括每个表或者索引的页面个数，索引的基数，索引和数据行的长度，索引分布的情况。</p>
<p>优化器在评估成本的时候，不会考虑任何缓存的作用，而是假设读取任何数据都需要经过一次IO操作。</p>
<h1 id="优化器可以做哪些优化"><a href="#优化器可以做哪些优化" class="headerlink" title="优化器可以做哪些优化"></a>优化器可以做哪些优化</h1><p>优化器可以替我们做很多优化，下面列举一些常用的优化：</p>
<ul>
<li>重新定义关联的顺序。优化器并不一定按照我们写的查询关联语句中的关联顺序，而是会按照优化后的顺序进行查询。</li>
<li>将外连接转为为内连接。</li>
<li>使用等价转换原则。比如a&lt;b and a=5会被转换为a=5 and b&gt;5</li>
<li>优化COUNT(),MIN()和MAX()</li>
<li>预估并转化为常数表达式</li>
<li>覆盖索引扫描。想要详细了解覆盖索引的可以点击这里。</li>
<li>的查询优化。</li>
<li>提前终止查询。比如我们使用了一个不成立的条件，则会立刻返回空。</li>
<li>等值传播。</li>
<li>优化IN()语句。在其他很多数据库中in等同于or语句，但是MySQL中会讲in中的值先进行排序，然后按照二分查找的方法来确定是否满足条件。</li>
</ul>
<p>实际当中优化器能做的优化远远比上面列举的更多，所以有时候我们不要觉得比优化器更聪明，所以大部分情况下我们都可以让优化器做出优化就可以了，如果有些我们确定优化器没有选择最优的查询方案，我们也可以在查询中通过添加hint提示告知到优化器，比如通过force index强制使用索引或者straight_join语句强制优化器按我们想要的表顺序进行关联。</p>
<h1 id="优化器并不是万能的"><a href="#优化器并不是万能的" class="headerlink" title="优化器并不是万能的"></a>优化器并不是万能的</h1><p>MySQL优化器也并不是万能的，并不是总能把我们写的糟糕的sql语句优化成一个高效的查询语句，而且也有很多种原因会导致优化器做出错误的选择：</p>
<ul>
<li>统计信息不准确。MySQL评估成本依赖于存储引擎提供的的统计信息，然而存储引擎提供的统计信息有时候会有较大偏差。</li>
<li>执行计划的成本估算不等于实际的执行成本。比如估算成本的时候不考虑缓存，而实际执行有些数据在缓存中。</li>
<li>优化器认为的最优可能并不是我们需要的最优。比如有时候我们想要时间最短，但是优化器</li>
<li>优化器从不考虑其他并发的查询。</li>
<li>优化器并不总是基本成本的优化。有时候也会基于规则，比如当存在全文索引，查询时使用了match()子句时，即使选择其他索引更优，优化器仍然会选择全文索引。</li>
<li>优化器不将不受其控制的操作计算为成本。如执行存储过程或者用户自定义函数的成本。</li>
<li>优化器有时候无法估算所有的执行计划，所以也有可能错过最优执行计划。</li>
</ul>
<h1 id="优化器如何得到查询计划"><a href="#优化器如何得到查询计划" class="headerlink" title="优化器如何得到查询计划"></a>优化器如何得到查询计划</h1><p>优化器听起来比较抽象，给人一种看不见摸不着的感觉，但是实际上我们也可以通过参数打开优化器追踪，优化器追踪默认是关闭的，因为开启后会影响性能，所以建议是在需要定位问题的时候开启，并及时关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;optimizer_trace&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set optimizer_trace=&#x27;enabled=on&#x27;;</span><br></pre></td></tr></table></figure>

<p>接下来执行一句查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name AS name1,t2.name AS name2 FROM test t1 INNER JOIN test2 t2 ON t1.id=t2.id</span><br></pre></td></tr></table></figure>

<p>这时候优化器的分析过程已经被记录下来了，可以通过下面语句查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.optimizer_trace;</span><br></pre></td></tr></table></figure>

<p>得到如下结果：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2Y2YzcwY2VlMDkwYTQyOWJhZTRiMjZiODE0YjBjNTFl?x-oss-process=image/format,png" alt="详解一条查询select语句和更新update语句的执行流程"></p>
<p>上面的图是为了看数据效果，如果需要自己操作的话，需要用shelll命令窗口去执行，sqlyog工具中直接查询出来TRACE列是空的，shell中返回的TRACE列信息如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzgwNzIzMDMwY2UzMTQ1Yjk5ZTM2NGRhODhjYjU5N2Iz?x-oss-process=image/format,png" alt="详解一条查询select语句和更新update语句的执行流程"></p>
<p>从截图中的轮廓可以看出来这是一个json数据格式。</p>
<p>跟踪信息主要分为以下三部分(上图并未将全部内容展示出来，感兴趣的可以自己去尝试一下，开启之后记得及时关闭哦)：</p>
<ul>
<li>准备阶段(join_preparation)：expanded_query中的查询语句就是优化后的sql</li>
<li>优化阶段(join_optimization)：considered_execution_plans中列出来所有的执行计划</li>
<li>执行阶段(join_execution)</li>
</ul>
<h1 id="存储引擎查询"><a href="#存储引擎查询" class="headerlink" title="存储引擎查询"></a>存储引擎查询</h1><p>当Server层得到了一条sql语句的执行计划后，这时候就会去调用存储引擎层对应的API，执行查询了。因为MySQL的存储引擎是插件式的，所以每种存储引擎都会对Server提供了一些对应的API调用。</p>
<h1 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h1><p>最后，将查询出得到的结果返回Server层，如果开启了缓存，Server层返回数据的同时还会写入缓存。</p>
<p>MySQL将查询结果返回是一个增量的逐步返回过程。例如：当我们处理完所有查询逻辑并开始执行查询并且生成第一条结果数据的时候，MySQL就可以开始逐步的向客户端传输数据了。这么做的好处是服务端无需存储太多结果，从而减少内存消耗(这个操作可以通过sql _buffer_result来提示优化器，和上文说的force index，straight_join一样都是人为强制优化器执行我们想要的操作)。</p>
<h1 id="一条update语句的执行流程"><a href="#一条update语句的执行流程" class="headerlink" title="一条update语句的执行流程"></a>一条update语句的执行流程</h1><p>一条更新语句，其实是增，删，查的综合体，查询语句需要经过的流程，更新语句全部需要执行一次，因为更新之前必须要先拿到(查询)需要更新的数据。</p>
<h1 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h1><p>InnnoDB的数据都是放在磁盘上的，而磁盘的速度和CPU的速度之间有难以逾越的鸿沟，为了提升效率，就引入了缓冲池技术，在InnoDB中称之为Buffer Pool。</p>
<p>从磁盘中读取数据的时候，会先将从磁盘中读取到的页放在缓冲池中，这样下次读相同的页的时候，就可以直接从Buffer Pool中获取。</p>
<p>更新数据的时候首先会看数据在不在缓冲池中，在的话就直接修改缓冲池中的数据，注意，<strong>前提是我们不需要对这条数据进行唯一性检查（因为如果要进行唯一性检查就必须加载磁盘中的数据来判断是否唯一了）</strong></p>
<p>如果只修改了Buffer Pool中的数据而不修改磁盘中数据，这时候就会造成内存和磁盘中数据不一致，这种也叫做脏页。InnoDB 里面有专门的后台线程把 Buffer Pool 的数据写入到磁盘， 每隔一段时间就一次性地把多个修改写入磁盘，这个动作就叫做刷脏。</p>
<p>那么现在有一个问题，假如我们更新都需要把数据写入数据磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，InnoDB就有了redo log,并且采用了Write-Ahead Logging(WAL)方案实现。</p>
<h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><p>redo log，即重做日志，是InnoDB引擎所特有,主要用于崩溃修复(crash-safe)。</p>
<h1 id="Write-Ahead-Logging（WAL）"><a href="#Write-Ahead-Logging（WAL）" class="headerlink" title="Write-Ahead Logging（WAL）"></a>Write-Ahead Logging（WAL）</h1><p>Write-Ahead Logging，即先写日志，也就是说我们执行一个操作的时候会先将操作写入日志，然后再写入数据磁盘，那么有人就会问了，写入数据表是磁盘操作，写入redo log也是磁盘操作，同样都是写入磁盘，为什么不直接写入数据，而要先写入日志呢？这不是多此一举吗？</p>
<p>设想一下，假如我们所需要的数据是随机分散在不同页的不同扇区中，那么我们去找数据的时候就是随机IO操作，而redo log是循环写入的，也就是顺序IO。一句话：<br><strong>刷盘是随机 I/O，而记录日志是顺序 I/O，顺序 I/O 效率更高。因此先把修改写入日 志，可以延迟刷盘时机，进而提升系统吞吐</strong></p>
<h1 id="redo-log是如何刷盘的"><a href="#redo-log是如何刷盘的" class="headerlink" title="redo log是如何刷盘的"></a>redo log是如何刷盘的</h1><p>InnoDB中的 redo log是固定大小的，也就是说redo log并不是随着文件写入慢慢变大，而是一开始就分配好了空间，空间一旦写满了，前面的空间就会被覆盖掉，刷盘的操作是通过Checkpoint实现的。如下图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzQ5MDYxMDQ4NGU3NTQzZGQ5OTQzZGYwM2YzMzFlMzAz?x-oss-process=image/format,png" alt="详解一条查询select语句和更新update语句的执行流程"></p>
<p>check point 是当前要覆盖的位置。write pos是当前写入日志的位置。写日志的时候是循环写的，覆盖旧记录前要把记录更新到数据文件。如果write pos和 check point 重叠，说明redo log 已经写满，这时候需要同步redo log刷到磁盘中。</p>
<h1 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h1><p>MySQL整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面讲的redo log是InnoDB 引擎特有的日志，而Server 层也有自己的日志，称为 binlog（归档日志），也叫做二进制日志。</p>
<p>可能有人会问，为什么会有两份日志呢？<br>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM是不支持事物的，也没有崩溃恢复(crash-safe)的能力，binlog日志只能用于归档。那么既然InnoDB是需要支持事务的，那么就必须要有崩溃恢复(crash-safe)能力，所以就使用另外一套自己的日志系统，也就是基于redo log 来实现 crash-safe 能力。</p>
<h1 id="bin-log和redo-log的区别"><a href="#bin-log和redo-log的区别" class="headerlink" title="bin log和redo log的区别"></a>bin log和redo log的区别</h1><p>1、redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的Server层实现的，所有引擎都可以使用。<br>2、redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给id=2 这一行的c字段加 1 ”。<br>3、redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>
<h1 id="update语句的执行流程"><a href="#update语句的执行流程" class="headerlink" title="update语句的执行流程"></a>update语句的执行流程</h1><p>前面铺垫了这么多，主要是想让大家先理解redo log和big log这两个概念，因为更新操作离不开这两个文件，接下来我们正式回到正题，一条update语句到底是如何执行的，可以通过下图表示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzdmMTZjMGUyMWFiYTRhZTc4YWIwZjViY2JmMzY2ZDdk?x-oss-process=image/format,png" alt="详解一条查询select语句和更新update语句的执行流程"></p>
<p>上图可以大概概括为以下几步：<br>1、先根据更新语句的条件，查询出对应的记录，如果有缓存，也会用到缓存<br>2、Server端调用InnoDB引擎API接口，InnoDB引擎将这条数据写到内存，同时写入redo log，并将redo log状态设置为prepare<br>3、通知Server层，可以正式提交数据了<br>4、Server层收到通知后立刻写入bin log，然后调用InnoD对应接口发出commit请求<br>5、InnoDB收到commit请求后将数据设置为commit状态</p>
<p>上面的步骤中，我们注意到，redo log会经过两次提交，这就是两阶段提交。</p>
<h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><p>两阶段提交是分布式事务的设计思想，就是首先会有请求方发出请求到各个服务器，然后等其他各个服务器都准备好之后再通知请求方可以提交了，请求方收到请求后再发出指令，通知所有服务器一起提交。</p>
<p>而我们这里redo log是属于存储引擎层的日志，bin log是属于Server层日志，属于两个独立的日志文件，采用两阶段提交就是为了使两个日志文件逻辑上保持一致</p>
<h1 id="假如不采用两阶段提交法"><a href="#假如不采用两阶段提交法" class="headerlink" title="假如不采用两阶段提交法"></a>假如不采用两阶段提交法</h1><p>假如有一条语句id=1,age=18，我们现在要把这条数据的age更新为19：</p>
<ul>
<li>先写 redo log 后写 binlog<br>假设在redo log 写完，binlog还没有写完的时候，MySQL发生了宕机(crash)。重启后因为redo log写完了，所以会自动进行数据恢复，也就是age=19。但是由于binlog没写完就宕机( crash)了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后某一天假如我们把数据丢失了，需要用bin log进行数据恢复就会发现少了这一次更新。</li>
<li>先写binlog后写redo log<br>假如在binlog写完，redo log还没有写完的时候，MySQL发生了宕机(crash)。重启后因为redo log没写完，所以无法进行自动恢复，那么数据就还是age=18了，然后某一天假如我们把数据丢失了，需要用binlog进行恢复又会发现恢复出来的数据age=19了。</li>
</ul>
<p>通过以上的两个假设我们就会发现，假如不采用两阶段提交法就会出现数据不一致的情况，尤其是在有主从库的时候，因为主从复制是基于binlog实现的，如果redo log和bin log不一致，就会导致主从库数据不一致。</p>
<h1 id="宕机后的数据恢复规则"><a href="#宕机后的数据恢复规则" class="headerlink" title="宕机后的数据恢复规则"></a>宕机后的数据恢复规则</h1><p>1、如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；<br>2、如果 redo log 里面的事物只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：如果是，则提交事务；否则，回滚事务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要分析了select和update语句的执行过程，而在分析update语句执行过程中，又简单介绍了redo log和bin log相关概念，这一部分内容在本文中没有过多深入的讲解，仅仅只是为了让大家去理解更新流程而做了简单的介绍，像redo log和其对应的缓存之间的关系，redo log刷盘策略，bin log写入策略，有了bin log为何还需要redo log等等问题本文中并没有给出明确的解释，因为本文篇幅有限，深入之后就会涉及到InnoDB引擎的存储结构以及更底层的一些知识</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2021/01/08/Redis%E8%A1%A5%E5%85%85%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%89-redis%E8%A1%A5%E5%85%85%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/08/Redis%E8%A1%A5%E5%85%85%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%89-redis%E8%A1%A5%E5%85%85%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">Redis补充（数据类型以及使用场景）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-08 12:05:35" itemprop="dateCreated datePublished" datetime="2021-01-08T12:05:35+08:00">2021-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:46:53" itemprop="dateModified" datetime="2022-09-22T22:46:53+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>之前对Redis写了很多文章了。其中Redis（二）介绍了数据类型和操作。</p>
<p>这篇文章作为补充，并且侧重于是介绍一下每一种类型的使用场景</p>
<p>具体操作这里就不一一列举了。可以查看或之前的博客或者去<a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-commands.html">菜鸟网</a></p>
</blockquote>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p><strong>实际中如何给Key命名？</strong></p>
<ul>
<li>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</li>
<li>控制key的长度不能太长</li>
<li>不要包含特殊字符：换行、双引号、空格等</li>
</ul>
<p><strong>Value不能太大</strong></p>
<p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，Redis4.0支持了异步del）</p>
<p>举例（这是hash类型）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset user:1 name tom age 19 favor football</span><br></pre></td></tr></table></figure>

<p><strong>尽量均匀的设置过期时间</strong></p>
<p>更多参考此博客：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92633604">https://zhuanlan.zhihu.com/p/92633604</a></p>
<h2 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h2><p>结构：简单的Key-Value形式，Value是一个字符串</p>
<p>场景：</p>
<p>String是最基本、常用的数据类型</p>
<ul>
<li>可以用来存储普通的、JSON等形式的字符串数据</li>
<li>假如数据正好是一个整数，那么你可以使用 <code>incr</code>命令让他进行原子自增，或<code>decr</code>原子自减【注意小数是不行的】</li>
</ul>
<p>hash</p>
<p>结构：Value是一个类似Map的结构</p>
<p>容量：Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）</p>
<p>场景：hash类型非常适合用来存储对象类的数据，假如在String里存储一个JSON格式的字符串来保存对象，在存入、取出时还需要来回转换。而hash更加直接快速，还可以动态的添加或删除”字段名”,更加灵活</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>结构：</p>
<p>Redis中list的实现是一个双向链表，并不是数据。<code>lpush rpush</code>分别对应头插入和尾部插入。</p>
<p>同样我们也可以选择<code>lpop rpop</code>来进行头部移出，和尾部移出。这样list的也就相当于<strong>队列</strong>或者<strong>栈</strong>了</p>
<p>容量：一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)</p>
<p>场景：</p>
<ol>
<li>消息队列</li>
</ol>
<p>list类型的lpop和rpush（或者反过来，lpush和rpop）能实现队列的功能，故而可以用Redis的list类型实现简单的点对点的消息队列。不过我不推荐在实战中这么使用，因为现在已经有Kafka、NSQ、RabbitMQ等成熟的消息队列了，它们的功能已经很完善了，除非是为了更深入地理解消息队列，不然我觉得没必要去重复造轮子。</p>
<p> 　2. 排行榜</p>
<p>list类型的lrange命令可以分页查看队列中的数据。可将每隔一段时间计算一次的排行榜存储在list类型中，如京东每日的手机销量排行、学校每次月考学生的成绩排名、斗鱼主播排名等</p>
<ol start="3">
<li>最新列表</li>
</ol>
<p>　　list类型的lpush命令和lrange命令能实现最新列表的功能，每次通过lpush命令往列表里插入新的元素，然后通过lrange命令读取最新的元素列表，如朋友圈的点赞列表、评论列表。</p>
<p>　　但是，并不是所有的最新列表都能用list类型实现，因为对于频繁更新的列表，list类型的分页可能导致列表元素重复或漏掉，举个例子，当前列表里由表头到表尾依次有（E，D，C，B，A）五个元素，每页获取3个元素，用户第一次获取到（E，D，C）三个元素，然后表头新增了一个元素F，列表变成了（F，E，D，C，B，A），此时用户取第二页拿到（C，B，A），元素C重复了。只有不需要分页（比如每次都只取列表的前5个元素）或者更新频率低（比如每天凌晨更新一次）的列表才适合用list类型实现。对于需要分页并且会频繁更新的列表，需用使用有序集合sorted set类型实现。另外，需要通过时间范围查找的最新列表，list类型也实现不了，也需要通过有序集合sorted set类型实现，如以成交时间范围作为条件来查询的订单列表。</p>
<blockquote>
<p>为何不直接使用sorted set？</p>
<p>对于排行榜和最新列表两种应用场景，list类型能做到的sorted set类型都能做到，list类型做不到的sorted set类型也能做到，那为什么还要使用list类型去实现排行榜或最新列表呢，直接用sorted set类型不是更好吗？原因是sorted set类型占用的内存容量是list类型的数倍之多，对于列表数量不多的情况，可以用sorted set类型来实现，比如上文中举例的打擂金曲排行榜，每天全国只有一份，两种数据类型的内存容量差距可以忽略不计，但是如果要实现某首歌曲的翻唱作品地区排行榜，数百万的歌曲，300多个地区，会产生数量庞大的榜单，或者数量更加庞大的朋友圈点赞列表，就需要慎重地考虑容量的问题了</p>
</blockquote>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>结构：</p>
<ul>
<li>是一个无序、不重复集合。若添加了一个重复的元素，则反回0（失败）</li>
<li>提供了多个set之间的聚合运算：如何求交集、并集、差集等</li>
<li>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</li>
</ul>
<p>容量：集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)</p>
<p>使用场景：</p>
<ol>
<li>好友/关注/粉丝/感兴趣的人集合</li>
</ol>
<p>　　set类型唯一的特点使得其适合用于存储好友/关注/粉丝/感兴趣的人集合，集合中的元素数量可能很多，每次全部取出来成本不小，set类型提供了一些很实用的命令用于直接操作这些集合，如</p>
<p>　　　a. sinter命令可以获得A和B两个用户的共同好友</p>
<p>　　   b. sismember命令可以判断A是否是B的好友</p>
<p>   　　c. scard命令可以获取好友数量</p>
<p>   　　d. 关注时，smove命令可以将B从A的粉丝集合转移到A的好友集合</p>
<p>​           f. sdiff 返回第一个集合与其他集合之间的差异。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将ABCD存入集合 set1 中</span></span><br><span class="line">127.0.0.1:6379&gt; sadd set1 A B C D</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"><span class="comment">#将BD存入集合 set1 中</span></span><br><span class="line">127.0.0.1:6379&gt; sadd set2 B D</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment">#求set1 set2交集</span></span><br><span class="line">127.0.0.1:6379&gt; sinter set1 set2</span><br><span class="line">1) <span class="string">&quot;D&quot;</span></span><br><span class="line">2) <span class="string">&quot;B&quot;</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="comment">#Redis Sdiff 命令返回第一个集合与其他集合之间的差异，</span></span><br><span class="line"><span class="comment">#也可以认为说第一个集合中独有的元素。不存在的集合 key 将视为空集</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="comment">#求set1 与 set2的差集</span></span><br><span class="line">127.0.0.1:6379&gt; sdiff set1 set2</span><br><span class="line">1) <span class="string">&quot;A&quot;</span></span><br><span class="line">2) <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="comment">#求set2 与 set1的差集</span></span><br><span class="line">127.0.0.1:6379&gt; sdiff set2 set1</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"><span class="comment">#判断A 是否在结合set1中</span></span><br><span class="line">127.0.0.1:6379&gt; sismember set1 A</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>　　需要注意的是，如果你用的是Redis Cluster集群，对于sinter、smove这种操作多个key的命令，要求这两个key必须存储在同一个slot（槽位）中，否则会报出 (error) CROSSSLOT Keys in request don’t hash to the same slot 错误。Redis Cluster一共有16384个slot，每个key都是通过哈希算法CRC16(key)获取数值哈希，再模16384来定位slot的。要使得两个key处于同一slot，除了两个key一模一样，还有没有别的方法呢？答案是肯定的，Redis提供了一种<strong>Hash Tag</strong>的功能，在key中使用{}括起key中的一部分，在进行 CRC16(key) mod 16384 的过程中，只会对{}内的字符串计算，例如friend_set:{123456}和fans_set:{123456}，分别表示用户123456的好友集合和粉丝集合，在定位slot时，只对{}内的123456进行计算，所以这两个集合肯定是在同一个slot内的，当用户123456关注某个粉丝时，就可以通过smove命令将这个粉丝从用户123456的粉丝集合移动到好友集合。相比于通过srem命令先将这个粉丝从粉丝集合中删除，再通过sadd命令将这个粉丝加到好友集合，smove命令的优势是它是原子性的，不会出现这个粉丝从粉丝集合中被删除，却没有加到好友集合的情况。然而，对于通过sinter获取共同好友而言，Hash Tag则无能为力，例如，要用sinter去获取用户123456和456789两个用户的共同好友，除非我们将key定义为{friend_set}:123456和{friend_set}:456789，否则不能保证两个key会处于同一个slot，但是如果真这样做的话，所有用户的好友集合都会堆积在同一个slot中，数据分布会严重不均匀，不可取，所以，****在实战中**使用Redis Cluster时，sinter这个命令其实是不适合作用于两个不同用户对应的集合的**（同理其它操作多个key的命令）。</p>
<p> 　2. 随机展示</p>
<p>　　通常，app首页的展示区域有限，但是又不能总是展示固定的内容，一种做法是先确定一批需要展示的内容，再从中随机获取。如下图所示，酷狗音乐K歌擂台赛当日的打擂歌曲共29首，首页随机展示5首；昨日打擂金曲共200首，首页随机展示30首。</p>
<p>　　set类型适合存放所有需要展示的内容，而<code>srandmember</code>命令则可以从中随机获取几个。</p>
<p> 　3. 黑名单/白名单</p>
<p>　　经常有业务出于安全性方面的考虑，需要设置用户黑名单、ip黑名单、设备黑名单等，set类型适合存储这些黑名单数据，<code>sismember</code>命令可用于判断用户、ip、设备是否处于黑名单之中。</p>
<h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h2><p>与set一样是一个不重复的集合。区别是集合中每一个成员都会有一个分数。</p>
<ul>
<li>不同的是每个元素都会关联一个 double 类型的分数</li>
<li>redis 正是通过分数来为sorted set集合中的成员进行从小到大的排序。</li>
<li>有序集合的成员是唯一的,但分数(score)却可以重复</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#向zset1集合中 存入三个成员</span></span><br><span class="line">127.0.0.1:6379&gt; zadd zset1 100 xiaoming 50 red 10.6 green</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment">#查询0-2索引范围的数据 默认正序：从小到大</span></span><br><span class="line">127.0.0.1:6379&gt; zrange zset1 0 2</span><br><span class="line">1) <span class="string">&quot;green&quot;</span></span><br><span class="line">2) <span class="string">&quot;red&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="comment">#查询0-2索引范围的数据，倒叙 revrange-&gt; reverse range</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrange zset1 0 2</span><br><span class="line">1) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">2) <span class="string">&quot;red&quot;</span></span><br><span class="line">3) <span class="string">&quot;green&quot;</span></span><br><span class="line"><span class="comment">#查询某个成员的分数</span></span><br><span class="line">127.0.0.1:6379&gt; zscore zset1  green</span><br><span class="line"><span class="string">&quot;10.6&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>带分数的排名：比如商品销量排名，游戏玩家积分排名等等</p>
<h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2><p>位图：当做是一个bit数组，我们向每一位来set设置0或1，也可以get</p>
<p>场景：</p>
<ul>
<li>设置用户在线状态，所有用户用一个key，用户id作为offset</li>
<li>用户签到情况，每一个用户作为一个bitmap的key</li>
</ul>
<h2 id="hyperLoglog"><a href="#hyperLoglog" class="headerlink" title="hyperLoglog"></a>hyperLoglog</h2><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<blockquote>
<p>什么是基数?</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
</blockquote>
<h2 id="geo"><a href="#geo" class="headerlink" title="geo"></a>geo</h2><p>GEO即地址信息定位<br>可以用来存储经纬度，计算两地距离，范围计算等</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h2><ul>
<li>Redis应用类型及应用场景 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012212663?utm_source=tag-newest">https://segmentfault.com/a/1190000012212663?utm_source=tag-newest</a></li>
<li>Redis实战经验 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/pangzizhe/p/10674501.html">https://www.cnblogs.com/pangzizhe/p/10674501.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/renpingsheng/p/9783834.html">https://www.cnblogs.com/renpingsheng/p/9783834.html</a></li>
</ul>
<blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2021/01/05/%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98-%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/05/%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98-%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">端口占用问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-05 00:29:38" itemprop="dateCreated datePublished" datetime="2021-01-05T00:29:38+08:00">2021-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:47:39" itemprop="dateModified" datetime="2022-09-22T22:47:39+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>在运行程序时，有时会出现程序莫名其妙不能启动的情况。根据Log提示或猜测可能是端口占用的情况。</strong></p>
<p>解决办法：</p>
<ol>
<li>netstat -aon|findstr [端口号]（查看端口是否被占用）</li>
<li>tasklist|findstr [进程号PID] （查看占用端口的进程）</li>
<li>taskkill  /pid [进程号PID] -f -t 杀死进程（或在任务管理器中结束该进程）<blockquote>
<p>/PID processid    指定要终止的进程的 PID。</p>
</blockquote>
</li>
</ol>
<p>-F                指定强制终止进程。<br>-T              终止指定的进程和由它启用的子进程</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/12/31/POI%E6%93%8D%E4%BD%9CExcel-poi%E6%93%8D%E4%BD%9Cexcel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/31/POI%E6%93%8D%E4%BD%9CExcel-poi%E6%93%8D%E4%BD%9Cexcel/" class="post-title-link" itemprop="url">POI操作Excel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-31 09:54:42" itemprop="dateCreated datePublished" datetime="2020-12-31T09:54:42+08:00">2020-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:46:05" itemprop="dateModified" datetime="2022-09-22T22:46:05+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="POI操作Excel"><a href="#POI操作Excel" class="headerlink" title="POI操作Excel"></a>POI操作Excel</h1><ul>
<li>获取Excel对象，并写值</li>
<li>如何插入行？</li>
<li>如何保存更改或下载</li>
</ul>
<h4 id="POI操作Excel，读取Excel并对单元格进行赋值"><a href="#POI操作Excel，读取Excel并对单元格进行赋值" class="headerlink" title="POI操作Excel，读取Excel并对单元格进行赋值"></a>POI操作Excel，读取Excel并对单元格进行赋值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置文件路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="comment">//根据文件路径获取输入流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line"><span class="comment">//获取文档对象</span></span><br><span class="line"><span class="type">Workbook</span> <span class="variable">wb</span> <span class="operator">=</span> WorkbookFactory.create(input);</span><br><span class="line"><span class="comment">//获取第一个Sheet页，也有方法可以根据Sheet的名字获取</span></span><br><span class="line"><span class="type">Sheet</span> <span class="variable">sheet</span> <span class="operator">=</span> wb.getSheetAt(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//获取该Sheet的第一行对象</span></span><br><span class="line"><span class="type">Row</span> <span class="variable">row</span> <span class="operator">=</span> sheet.getRow(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//获取第一个单元格元素</span></span><br><span class="line"> <span class="type">Cell</span> <span class="variable">cell</span> <span class="operator">=</span> row2.getCell(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置单元格的值</span></span><br><span class="line">cell.setCellValue(<span class="string">&quot;your value&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="当需要插入行时，需要两步"><a href="#当需要插入行时，需要两步" class="headerlink" title="当需要插入行时，需要两步"></a>当需要插入行时，需要两步</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 先用shiftRows方法将行向下移动，</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	参数1：startRow从第几行开始移动，</span></span><br><span class="line"><span class="comment">	参数2：从参数一的行数到sheet的最后一行，一并向下移动</span></span><br><span class="line"><span class="comment">	参数3：count：移动几行</span></span><br><span class="line"><span class="comment">	参数4与参数5与行高有关，是Boolean类型，根据情况自行设置</span></span><br><span class="line"><span class="comment"> * Shifts rows between startRow and endRow n number of rows.</span></span><br><span class="line"><span class="comment"> * If you use a negative number, it will shift rows up.</span></span><br><span class="line"><span class="comment"> * Code ensures that rows don&#x27;t wrap around</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Additionally shifts merged regions that are completely defined in these</span></span><br><span class="line"><span class="comment"> * rows (ie. merged 2 cells on a row to be shifted).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startRow the row to start shifting</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endRow the row to end shifting</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n the number of rows to shift</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> copyRowHeight whether to copy the row height during the shift</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resetOriginalRowHeight whether to set the original row&#x27;s height to the default</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">shiftRows</span><span class="params">(<span class="type">int</span> startRow, <span class="type">int</span> endRow, <span class="type">int</span> n, <span class="type">boolean</span> copyRowHeight, <span class="type">boolean</span> resetOriginalRowHeight)</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 当移动行后，在Sheet对象中row会空出来几个比如从<span class="number">1</span>~<span class="number">3</span>  <span class="number">8</span>~<span class="number">15.</span>这时<span class="number">3</span>~<span class="number">8</span>是没有row对象的。</span><br><span class="line">    需要我们来自己创建row对象，并依据上面的样式补充单元格。</span><br><span class="line">	 <span class="type">Row</span> <span class="variable">rowSource</span> <span class="operator">=</span> sheet.getRow(n);<span class="comment">//复制哪一行的样式 n就是几</span></span><br><span class="line">	<span class="comment">//遍历中间的行数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startRow; i &lt; startRow+count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Row</span> <span class="variable">rowInsert</span> <span class="operator">=</span> sheet.createRow(i);</span><br><span class="line">        rowInsert.setRowStyle(rowSource.getRowStyle());</span><br><span class="line">        rowInsert.setHeight(rowSource.getHeight());</span><br><span class="line">		<span class="comment">//遍历每一行的单元格数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; rowSource.getLastCellNum(); col++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Cell</span> <span class="variable">cellsource</span> <span class="operator">=</span> rowSource.getCell(col);</span><br><span class="line">            <span class="type">Cell</span> <span class="variable">cellInsert</span> <span class="operator">=</span> rowInsert.createCell(col);</span><br><span class="line">            cellInsert.setCellStyle(cellsource.getCellStyle());</span><br><span class="line">            <span class="comment">//这几句话是由于我需要合并单元格</span></span><br><span class="line">            <span class="type">CellRangeAddress</span> <span class="variable">region</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CellRangeAddress</span>(i, i, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="type">CellRangeAddress</span> <span class="variable">region2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CellRangeAddress</span>(i, i, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">            sheet.addMergedRegion(region);</span><br><span class="line">            sheet.addMergedRegion(region2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="保存或下载"><a href="#保存或下载" class="headerlink" title="保存或下载"></a>保存或下载</h4><p>1 保存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置文件路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="comment">//根据文件路径获取输入流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line"><span class="type">Workbook</span> <span class="variable">wb</span> <span class="operator">=</span> WorkbookFactory.create(input);</span><br><span class="line"><span class="comment">//根据文件路径获取输出流</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间写文件的操作.....</span></span><br><span class="line">    doSomeThing();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写出</span></span><br><span class="line">output.flush();</span><br><span class="line">wb.write(output);</span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">output.close();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>2 下载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理Excel</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dealExcel</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//设置文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">    <span class="comment">//根据文件路径获取输入流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">    <span class="type">Workbook</span> <span class="variable">wb</span> <span class="operator">=</span> WorkbookFactory.create(input);</span><br><span class="line">	<span class="comment">//中间写文件的操作.....</span></span><br><span class="line">    doSomeThing();</span><br><span class="line">    <span class="comment">//下载Excel</span></span><br><span class="line">    expotExcel(wb,<span class="string">&quot;文件名&quot;</span>,response);</span><br><span class="line">    <span class="comment">//关闭流</span></span><br><span class="line">    input.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//下载Excel</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span>   <span class="title function_">expotExcel</span><span class="params">(Workbook wb,String fileName,HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + URLEncoder.encode(fileName + <span class="string">&quot;.xlsx&quot;</span>, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/octet-stream;charset=utf-8&quot;</span>);</span><br><span class="line">        response.addHeader(<span class="string">&quot;Pargam&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        response.addHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            wb.write(outputStream);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            outputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/12/11/Zookeeper-zookeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/11/Zookeeper-zookeeper/" class="post-title-link" itemprop="url">Zookeeper</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-11 09:36:37" itemprop="dateCreated datePublished" datetime="2020-12-11T09:36:37+08:00">2020-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:47:28" itemprop="dateModified" datetime="2022-09-22T22:47:28+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dubbo-Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Dubbo + Zookeeper</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><ol>
<li>基于zk集群实现分布式配置中心</li>
</ol>
<h2 id="1-Zookeeper-是什么？"><a href="#1-Zookeeper-是什么？" class="headerlink" title="1. Zookeeper 是什么？"></a>1. Zookeeper 是什么？</h2><p>简单来说zookeeper=<strong>文件系统 + 监听通知机制</strong>。</p>
<h3 id="1-1-文件系统"><a href="#1-1-文件系统" class="headerlink" title="1.1 文件系统"></a>1.1 文件系统</h3><p>文件系统就是一个节点树，最头上的是根，</p>
<p>再往下就有各级目录，每个目录中或者是文件或者是下一级的目录</p>
<p><img src="https://hopestation.top/upload/2020/12/zk06-da25a3e62b294997bda9ed795302c1f9.png" alt="zk06.png"></p>
<p>每个子目录项如 NameService 都被称作为 znode(目录节点)，</p>
<p>和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，</p>
<p>唯一的不同在于znode是可以存储数据的</p>
<blockquote>
<p>需要额外注意以下几点：</p>
<ol>
<li><p>znode 中的数据可以有多个版本，在查询该 znode 数据时就需要带上版本信息。（set path version / delete path version）</p>
</li>
<li><p>znode 可以是临时 znode（create -e 生成的节点），一旦创建这个 znode 的 client 与server 断开连接，该znode 将被自动删除。client 和 server 之间通过 heartbeat 来确认连接正常，这种状态称之为 session，断开连接后 session 失效。</p>
</li>
<li><p>临时 znode 不能有子 znode。</p>
</li>
<li><p>znode 可以自动编号（create -s 生成的节点），例如在 create -s /app/node 已存在时，将会生成/app/node00***001 节点。</p>
</li>
<li><p>znode 可以被监控，该目录下某些信息的修改，例如节点数据、子节点变化等，可以主动通知监控注册的 client。事实上，通过这个特性，可以完成许多重要应用，例如配置管理、信息同步、分布式锁等等。</p>
</li>
</ol>
</blockquote>
<h3 id="1-2-监听通知机制"><a href="#1-2-监听通知机制" class="headerlink" title="1.2 监听通知机制"></a>1.2 监听通知机制</h3><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。</p>
<p>zookeeper功能非常强大，可以实现诸如分布式应用配置管理、统一命名服务、状态同步服务、集群管理等功能，</p>
<p>我们这里拿比较简单的分布式应用配置管理为例来说明。</p>
<p>假设我们的程序是分布式部署在多台机器上，如果我们要改变程序的配置文件，</p>
<p>需要逐台机器去修改，非常麻烦，现在把这些配置全部放到zookeeper上去，</p>
<p>保存在 zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，</p>
<p>一旦配置信息发生变化，每个应用程序就会收到 zookeeper 的通知，然后从 zookeeper 获取新的配置信息应用到系统中。</p>
<p><img src="https://hopestation.top/upload/2020/12/zk07-1aa4ac271aaf4aa3936e487142a9de8b.png" alt="zk07.png"></p>
<blockquote>
<p>每个ZNode上可存储少量数据(默认是1M, 可以通过配置修改, 通常不建议在ZNode上存储大量的数据)</p>
<p>配置文件文件大的话，个人建议不要用Zookeeper作为配置中心</p>
</blockquote>
<h3 id="1-3-概念"><a href="#1-3-概念" class="headerlink" title="1.3 概念"></a>1.3 概念</h3><p>先来看看官网的解释：</p>
<p><img src="https://hopestation.top/upload/2020/12/zk05-a24b3b6c2e7d47bc813180a8c5b334bc.png" alt="zk05"></p>
<p>关键信息：<strong>ZooKeeper是用于维护配置信息，命名，提供分布式同步以及提供组服务的集中式服务</strong>。</p>
<p><strong>配置管理</strong></p>
<p>在我们的应用中除了代码外，还有一些就是各种配置。比如数据库连接等。一般我们都是使用配置文件的方式，在代码中引入这些配置文件。但是当我们只有一种配置，只有一台服务器，并且不经常修改的时候，使用配置文件是一个很好的做法，但是如果我们配置非常多，有很多服务器都需要这个配置，而且还可能是动态的话使用配置文件就不是个好主意了。这个时候往往需要寻找一种集中管理配置的方法，我们在这个集中的地方修改了配置，所有对这个配置感兴趣的都可以获得变更。比如我们可以把配置放在数据库里，然后所有需要配置的服务都去这个数据库读取配置。但是，因为很多服务的正常运行都非常依赖这个配置，所以需要这个集中提供配置服务的服务具备很高的可靠性。一般我们可以用一个集群来提供这个配置服务，但是用集群提升可靠性，那如何保证配置在集群中的一致性呢？ 这个时候就需要使用一种实现了一致性协议的服务了。Zookeeper就是这种服务，它使用Zab这种一致性协议来提供一致性。现在有很多开源项目使用Zookeeper来维护配置，比如在HBase中，客户端就是连接一个Zookeeper，获得必要的HBase集群的配置信息，然后才可以进一步操作。还有在开源的消息队列Kafka中，也使用Zookeeper来维护broker的信息。在Alibaba开源的SOA框架Dubbo中也广泛的使用Zookeeper管理一些配置来实现服务治理。</p>
<p><strong>名字服务</strong></p>
<p>名字服务这个就很好理解了。比如为了通过网络访问一个系统，我们得知道对方的IP地址，但是IP地址对人非常不友好，这个时候我们就需要使用域名来访问。但是计算机是不能是别域名的。怎么办呢？如果我们每台机器里都备有一份域名到IP地址的映射，这个倒是能解决一部分问题，但是如果域名对应的IP发生变化了又该怎么办呢？于是我们有了DNS这个东西。我们只需要访问一个大家熟知的(known)的点，它就会告诉你这个域名对应的IP是什么。在我们的应用中也会存在很多这类问题，特别是在我们的服务特别多的时候，如果我们在本地保存服务的地址的时候将非常不方便，但是如果我们只需要访问一个大家都熟知的访问点，这里提供统一的入口，那么维护起来将方便得多了。</p>
<p><strong>分布式锁</strong></p>
<p>其实在第一篇文章中已经介绍了Zookeeper是一个分布式协调服务。这样我们就可以利用Zookeeper来协调多个分布式进程之间的活动。比如在一个分布式环境中，为了提高可靠性，我们的集群的每台服务器上都部署着同样的服务。但是，一件事情如果集群中的每个服务器都进行的话，那相互之间就要协调，编程起来将非常复杂。而如果我们只让一个服务进行操作，那又存在单点。通常还有一种做法就是使用分布式锁，在某个时刻只让一个服务去干活，当这台服务出问题的时候锁释放，立即fail over到另外的服务。这在很多分布式系统中都是这么做，这种设计有一个更好听的名字叫Leader Election(leader选举)。比如HBase的Master就是采用这种机制。但要注意的是分布式锁跟同一个进程的锁还是有区别的，所以使用的时候要比同一个进程里的锁更谨慎的使用。</p>
<blockquote>
<p>这段描述不够清晰，以后重新写一下</p>
</blockquote>
<p><strong>集群管理</strong></p>
<p>在分布式的集群中，经常会由于各种原因，比如硬件故障，软件故障，网络问题，有些节点会进进出出。有新的节点加入进来，也有老的节点退出集群。这个时候，集群中其他机器需要感知到这种变化，然后根据这种变化做出对应的决策。比如我们是一个分布式存储系统，有一个中央控制节点负责存储的分配，当有新的存储进来的时候我们要根据现在集群目前的状态来分配存储节点。这个时候我们就需要动态感知到集群目前的状态。还有，比如一个分布式的SOA架构中，服务是一个集群提供的，当消费者访问某个服务时，就需要采用某种机制发现现在有哪些节点可以提供该服务(这也称之为服务发现，比如Alibaba开源的SOA框架Dubbo就采用了Zookeeper作为服务发现的底层机制)。还有开源的Kafka队列就采用了Zookeeper作为Cosnumer的上下线管理。</p>
<blockquote>
<p>更详细的描述参考此文章：<a target="_blank" rel="noopener" href="https://www.yuque.com/realskrman/bi4s0n/ho3b8b">https://www.yuque.com/realskrman/bi4s0n/ho3b8b</a></p>
</blockquote>
<h3 id="1-4-服务注册中心"><a href="#1-4-服务注册中心" class="headerlink" title="1.4 服务注册中心"></a>1.4 服务注册中心</h3><p>Zookeeper是可以作为服务注册中心的，经常和Dubbo来整合使用。</p>
<p>除了Zookeeper，还有其他的注册中心：</p>
<ul>
<li>eureka：SpringCLoud项目产品</li>
<li>nacos：阿里产品，springcloud-alibaba集成</li>
<li>consul：HashiCorp 公司推出的开源工具</li>
<li>等..</li>
</ul>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><h3 id="2-1-单机测试"><a href="#2-1-单机测试" class="headerlink" title="2.1 单机测试"></a>2.1 单机测试</h3><h4 id="2-1-1-WIndow环境"><a href="#2-1-1-WIndow环境" class="headerlink" title="2.1.1 WIndow环境"></a>2.1.1 WIndow环境</h4><p>其实很简单，参考我的这个文章：<a target="_blank" rel="noopener" href="https://hopestation.top/archives/dz01#2-zookeeper%E5%AE%89%E8%A3%85">Dubbo + Zookeeper</a></p>
<h4 id="2-1-2-Linux环境"><a href="#2-1-2-Linux环境" class="headerlink" title="2.1.2 Linux环境"></a>2.1.2 Linux环境</h4><p>1、下载 首先我们下载稳定版本的zookeeper<a target="_blank" rel="noopener" href="http://zookeeper.apache.org/releases.html"> http://zookeeper.apache.org/releases.html</a> </p>
<p>2、上传 下载完成后，将zookee er压缩包<code>zookeeper-3.4.14.tar.gz</code>上传到linux系统 </p>
<p>3、解压缩压缩包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf zookeeper-3.4.14.tar.gz</span><br></pre></td></tr></table></figure>

<p>4、进入<code>zookeeper-3.4.14</code>目录，创建data文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> zookeeper-3.4.14 <span class="built_in">mkdir</span> data</span><br></pre></td></tr></table></figure>

<p>5、修改配置文件名称（因为Zookeeper默认读取的是 <code>zoo.cfg</code>文件）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> conf</span><br><span class="line"><span class="built_in">mv</span> zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>

<p>5、修改<code>zoo.cfg</code>中的data属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/root/zookeeper-3.4.14/data</span><br></pre></td></tr></table></figure>

<p>6、zookeeper服务启动 进入bin目录，输入命令<strong>启动服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>输出以下内容表示启动成功</p>
<p><img src="https://hopestation.top/upload/2020/12/zk08-391e20c13c8540e4bd9efc2a476377af.png" alt="zk08.png"></p>
<p>关闭服务输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh stop</span><br></pre></td></tr></table></figure>

<p>输出以下提示信息</p>
<p><img src="https://hopestation.top/upload/2020/12/zk09-e703395dce084c40a6a3f2df245b5723.png" alt="zk09.png"></p>
<p>查看状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh status</span><br></pre></td></tr></table></figure>

<p>如果启动状态，提示:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1699668/1597134783727-8bee52ce-fd06-451b-ba63-252826dd92f5.png" alt="image.png"></p>
<p>如果未启动状态，提示:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1699668/1597134794690-99319724-8d68-415a-bc0c-b73bf0431a7d.png" alt="image.png"></p>
<h3 id="2-2-伪集群模式"><a href="#2-2-伪集群模式" class="headerlink" title="2.2 伪集群模式"></a>2.2 伪集群模式</h3><p>这里介绍Linux搭建（WIndos也可以，步骤类似）</p>
<blockquote>
<p>首先来说并不太复杂，和我的<a target="_blank" rel="noopener" href="https://hopestation.top/archives/redis9">Redis的伪集群搭建</a>类似</p>
<p>大致步骤：1.复制修改三份配置文件，2. 启动三份服务</p>
<p>Zookeeper不但可以在单机上运行单机模式,Zookeeper,而且可以在单机模拟集群模式Zookee per的运行，也就是将不同实例运行在同一台机器，用端口进行区分，伪集群模式为我们体验Zookeeper和做一 些尝试性的实验提供了很大的便利。比如，我们在测试的时候，可以先使用少量数据在伪集群模式下进行测试。当测试可行的时候，再将数据移植到集群模式进行真实的数据实验。这样不但保证了它的可行 性，同时大大提高了实验的效率。这种搭建方式，比较简便，成本比较低，适合测试和学习 </p>
</blockquote>
<p>注意事项 : </p>
<p>—台机器上部署了 3个server，也就是说单台机器及上运行多个Zookeeper实例。这种情况下，必须保 证每个配置文档的各个端口号不能冲突，除client Port不同之外，dataDir也不同。另外，还要在 dataDir所对应的目录中创建myid文件来指定对应的Zookee per服务器实例</p>
<p>■ <strong>client Port 端口：</strong></p>
<p>如果在1台机器上部署多个server，那么每台机器都要不同的client Port，比如serverl是2181,server2 是2182, server3是2183 </p>
<p>■ <strong>dataDir 和 dataLogDir：</strong></p>
<p>dataDi r和dataLogDir也需要区分下，将数据文件和日志文件分开存放，同时每个server的这两变量所 对应的路径都是不同的 </p>
<p>■ <strong>server.X 和 yid：</strong></p>
<p>server.X这个数字就是对应，data/myid中的数字。在3个server的myid文件中分别写入了1, 2, 3,那 么每个serve r中的zoo.cfg都配server.1 server.2,server.3就行了。因为在同一台机器上，后面连着的2 个端口，3个server都不要一样，否则端口冲突</p>
<p>下载 </p>
<p>首先我们下载最新稳定版本的 zookee per<a target="_blank" rel="noopener" href="http://zookeeper.apache.org/releases.html"> htt p://zookee per.a pache.org/releases.html</a> 上传 下载完成后，将zookee per压缩包zookee per-3.4.14.tar.gz上传到linux系统 解压压缩包 创建目录zkcluster</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir zkcluster</span><br></pre></td></tr></table></figure>

<p>解压zookee per-3・4・14・tar・gz到zkcluster目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf zookeeper-3.4.14.tar.gz -C /zkcluster</span><br></pre></td></tr></table></figure>

<p>改变名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv zookeeper-3.4.14 zookeeper01</span><br></pre></td></tr></table></figure>

<p>复制并改名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r zookeeper01/ zookeeper02 cp -r zookeeper01/ zookeeper03</span><br></pre></td></tr></table></figure>

<p>分别在zookeeper01、zookeeper02、zookeeper03目录下创建data及logs目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br><span class="line">cd data</span><br><span class="line">mkdir logs</span><br></pre></td></tr></table></figure>

<p>修改配置文件名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd conf</span><br><span class="line">mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>

<p>配置每一个 Zookee per 的 dataDir (zoo.cfg) client Port 分别为2181 2182 2183</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clientPort=2181</span><br><span class="line">dataDir=/zkcluster/zookeeper01/data</span><br><span class="line">dataLogDir=/zkcluster/zookeeper01/data/logs</span><br><span class="line">clientPort=2182</span><br><span class="line">dataDir=/zkcluster/zookeeper02/data</span><br><span class="line">dataLogDir=/zkcluster/zookeeper02/data/logs</span><br><span class="line">clientPort=2183</span><br><span class="line">dataDir=/zkcluster/zookeeper03/data dataLogDir=/zkcluster/zookeeper03/data/logs</span><br></pre></td></tr></table></figure>

<p>配置集群</p>
<p>⑴ 在每个zookeeper的data目录下创建一个myid文件，内容分别是1、2、3。这个文件就是记录 每个服务器的ID</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch myid</span><br></pre></td></tr></table></figure>

<p>(2) 在每一个zookeeper的zoo.cfg配置客户端访问端口(clientPort)和集群服务器IP列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=10.211.55.4:2881:3881</span><br><span class="line">server.2=10.211.55.4:2882:3882</span><br><span class="line">server.3=10.211.55.4:2883:3883</span><br></pre></td></tr></table></figure>

<p># server.服务器ID=服务器IP地址：服务器之间通信端口：服务器之间投票选举端口</p>
<p>启动集群 依次启动三个zk实例</p>
<p>节点状态查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">node1</span><br><span class="line"># ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /app/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br><span class="line"></span><br><span class="line">#node2</span><br><span class="line"># ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /app/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Mode: leader</span><br><span class="line"></span><br><span class="line">#node3</span><br><span class="line"># ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /app/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure>

<h3 id="2-3-真集群模式"><a href="#2-3-真集群模式" class="headerlink" title="2.3 真集群模式"></a>2.3 真集群模式</h3><p>也就是相当于类似上面伪集群的操作。不过不是在一旦机器上配置三份。而是在三台服务器上配置三份。</p>
<h2 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3. 配置文件"></a>3. 配置文件</h2><p>上面的配置基本都是在 <code>zoo.cfg</code>，这里来解释一下配置文件的作用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cp conf/zoo_sample.cfg conf/zoo.cfg</span></span><br><span class="line"><span class="comment">#vim zoo.cfg</span></span><br><span class="line"><span class="comment"># zoo.cfg文件中内容如下</span></span><br><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="comment">#Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，每隔tickTime时间就会发送一个心跳，</span></span><br><span class="line"><span class="comment">#单位毫秒，最小的session过期时间为tickTime的两倍，ZK中的其他时间都是以这个为倍数的。</span></span><br><span class="line">tickTime=2000</span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="comment">#表示允许从服务器（相对于leader来说的客户端）连接到leader并完成数据同步的时间，</span></span><br><span class="line"><span class="comment">#它是以tickTime的倍数来表示的，也就是从服务器与主服务器完成初始化连接和数据同步是能够容忍多少个心跳时间，</span></span><br><span class="line"><span class="comment">#如果超过这个时间不能完成初始化连接的建立则表示连接失败。默认是10.</span></span><br><span class="line"><span class="comment">#如果你的数据量过大而且从服务器数量也多那么这个值可以设置大一点。</span></span><br><span class="line"><span class="comment">#总的时间长度就是 initLimit * tickTime 秒。</span></span><br><span class="line">initLimit=10  </span><br><span class="line"></span><br><span class="line"><span class="comment">#用于配置Leader服务器是否接受客户端的连接，是否允许Leader向客户端直接提供服务，默认是可以的。</span></span><br><span class="line"><span class="comment">#LeaderServes  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="comment">#配置 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，</span></span><br><span class="line"><span class="comment">#总的时间长度就是 syncLimit * tickTime 秒 ，如果在这个时间内从服务器不能与主服务器通信，</span></span><br><span class="line"><span class="comment">#则表示该从服务器失败。默认为5.如果集群环境网络不佳可以调整大一点。</span></span><br><span class="line">syncLimit=5     </span><br><span class="line"></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="comment">#Zookeeper 保存数据的数据库快照的位置，默认是/tmp/zookeeper，</span></span><br><span class="line"><span class="comment">#快照文件并不是实时的，运行一段时间才会有。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#事务日志日志路径，若没提供的话则用dataDir。zookeeper的持久化都存储在这两个目录里，</span></span><br><span class="line"><span class="comment">#对ZK的读和写都是在内存中完成，所以速度非常快，但是如果停止ZK再启动数据还是需要保证的，</span></span><br><span class="line"><span class="comment">#所以就会有这样一个路径用来保存事务日志，当ZK再次启动时加载到内存重演过程来恢复数据。</span></span><br><span class="line"><span class="comment">#dataLogDir里是放到的顺序日志(WAL),指定的目录下有version-2文件夹（下有log.1文件），</span></span><br><span class="line"><span class="comment">#这个目录确定了当前事务日志的版本号，当下次某个版本的ZK对其进行修改时，版本号发生变化。</span></span><br><span class="line"><span class="comment">#日志文件大小为64M，如果数据比较多就会有多个这样大小的文件。而dataDir里放的是内存数据结构的snapshot，</span></span><br><span class="line"><span class="comment">#便于快速恢复。为了达到性能最大化，一般建议把dataDir和dataLogDir分到不同的磁盘上，</span></span><br><span class="line"><span class="comment">#建议将事物日志保存到单独的磁盘而且是高速磁盘。因为为了一致性，</span></span><br><span class="line"><span class="comment">#ZK对于客户端的写入请求在返回之前就要把本次操作写入到事物日志中</span></span><br><span class="line">dataDir=/app/zookeeper/data   </span><br><span class="line">dataLogDir=/app/zookeeper/logs  </span><br><span class="line"></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="comment">#Zookeeper服务器监听的端口，以接受客户端的访问请求。</span></span><br><span class="line">clientPort=2181  </span><br><span class="line"></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#限制连接到ZK上的客户端数量，并且限制并发连接数量，它通过IP来区分不同客户端。</span></span><br><span class="line"><span class="comment">#值为0表示不做任何限制。注意这里的限制是针对单台客户端到服务器的，并不是控制所有客户端连接的。默认60.</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60   </span></span><br><span class="line"></span><br><span class="line">最小会话超时时间，默认为tickTime的2倍。不建议把这个值设置的比tickTime小。客户端连接到ZK时如果在这个最小时间内没有和ZK联系则标记为超时，也就是说会断开。</span><br><span class="line"><span class="comment">#minSessionTimeout=120     </span></span><br><span class="line"></span><br><span class="line">最大会话超时时间，默认为20倍的最小会话超时时间。不建议把这个值设置的比tickTime小。客户端连接到ZK时如果在这个最大时间内没有和ZK联系则标记为超时。所以上面的参数和这个参数组成了一个时间范围，也就是客户端连接ZK时如果在这个时间范围内没有成功连接则会标记为超时。如果客户端设置的时间范围不在这个服务器设置的范围内，则会被强制应用服务器设置的范围。</span><br><span class="line"><span class="comment">#maxSessionTimeout=2400     </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#自动清理日志，该参数设置保留多少个快照文件和对应的事务日志文件，默认为3，</span></span><br><span class="line"><span class="comment">#如果你设置的小于3则会被自动的调整为3</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3              </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to &quot;0&quot; to disable auto purge feature</span></span><br><span class="line"><span class="comment">#自动清理日志，该参数设置自动清理频率，上面的参数配套使用。</span></span><br><span class="line"><span class="comment">#客户端在和ZK服务器交互中服务器会产生很多日志，而且ZK会将内存中的数据作为快照保存起来，</span></span><br><span class="line"><span class="comment">#而且这些数据不会自动删除，那么磁盘空间就会被占用，可以设置这2个参数来自动清理，</span></span><br><span class="line"><span class="comment">#不过如果ZK服务器比较繁忙而且赶上删除日志任务就会影响性能，所以一般不设置这个自动清理，</span></span><br><span class="line"><span class="comment">#而是在ZK访问量少的时候通过Linux的定时任务来处理。0表示不开启自动清理功能。</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ZK的最大请求堆积数，客户端请求比较多，为了防止客户端资源过度消耗，服务器必须限制同时处理的请求数量。</span></span><br><span class="line"><span class="comment">#globalOutstandingLimit   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用于配置ZK事务日志预先分配的空间，默认是64M</span></span><br><span class="line"><span class="comment">#preAllocSize   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用于配置相邻两次快照之间的事物日志次数，默认是10万。也就是10万条事务之后做一次快照同时结转事务日志</span></span><br><span class="line"><span class="comment">#snapCount     </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这个参数针对多网卡的ZK服务器，允许为每个IP地址指定不同的监听端口。</span></span><br><span class="line"><span class="comment">#clientPortAddres     </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用于设置ZK服务器事物日志同步操作时消耗时间的报警阈值，如果实际消耗时长超过这个时间日志就会记录。</span></span><br><span class="line"><span class="comment">#fsync.warningthresholdms     </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用于配置Leader选举算法，目前只有一种选举算法，所以不用配置。</span></span><br><span class="line"><span class="comment">#electionAlg    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用于Leader选举时各个服务器之间进行的TCP连接创建超时时间，默认为5.</span></span><br><span class="line"><span class="comment">#cnxTimeout  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这个参数用于配置ZK服务器是否在事物提交时是否强制写入磁盘（LINUX的延迟写入），默认是YES。</span></span><br><span class="line"><span class="comment">#forceSync       </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用于配置单个数据节点上最大数量，默认是1MB。通常不需要改动该参数，但是因为Zookeeper不适合存放太多数据所以有时候需要把值改小</span></span><br><span class="line"><span class="comment">#jute.maxbuffer    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否跳过ACL检查，默认是no，也就是会对所有客户端连接进行acl检查。</span></span><br><span class="line"><span class="comment">#skipACL    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#其中X是一个数字, 表示这是第几号server，它的值和myid文件中的值对应。</span></span><br><span class="line"><span class="comment">#A是该server所在的IP地址。B是配置该server和集群中的leader交换消息所使用的端口。</span></span><br><span class="line"><span class="comment">#C配置选举leader时所使用的端口。由于配置的是伪集群模式，所以各个server的B, C参数必须不同，</span></span><br><span class="line"><span class="comment">#如果是真正分布式集群，那么B和C在各个节点上可以相同，</span></span><br><span class="line"><span class="comment">#因为即使相同由于节点处于不同的服务器也不会导致端口冲突。</span></span><br><span class="line"><span class="comment">#格式server.X=A:B:C</span></span><br><span class="line">server.1=10.55.2.81:2888:3888</span><br><span class="line">server.2=10.55.2.82:2888:3888</span><br><span class="line">server.3=10.55.2.83:2888:3888</span><br></pre></td></tr></table></figure>



<h2 id="4-系统模型"><a href="#4-系统模型" class="headerlink" title="4. 系统模型"></a>4. 系统模型</h2><p>ZooKee per 数据模型 Znode 在ZooKeeper中，数据信息被保存在一个个数据节点上，这些节点被称为znode。ZNode是Zookee per中最小数据单位，在ZNode下面又可以再挂ZNode，这样一层层下去就形成了一个层次化 命名空间ZNode树，我们称为ZNode Tree，它采用了类似文件系统的层级树状结构进行管理。见下图 示例：</p>
<p><img src="https://hopestation.top/upload/2020/12/zk12-76e9a131a4e74f609709b4ff6341efab.png" alt="zk12.png"></p>
<p>在Zookeeper中，每一个数据节点都是一个ZNode,上图根目录下有两个节点，分别是；app1和 app2,其中app1下面又有三个子节点，所有ZNode按层次化进行组织，形成这么一颗树，ZNode的节 点路径标识方式和Unix文件系统路径非常相似，都是由一系列使用斜杠(/)进行分割的路径表示，开 发人员可以向这个节点写入数据，也可以在这个节点下面创建子节点。</p>
<h3 id="4-1-ZNode类型"><a href="#4-1-ZNode类型" class="headerlink" title="4.1 ZNode类型"></a>4.1 ZNode类型</h3><p>刚刚已经了解到，Zookeeper的znode tree是由一系列数据节点组成的，那接下来，我们就对数据节点 做详细讲解</p>
<p>Zookee per节点类型可以分为三大类:</p>
<ul>
<li>持久性节点(Persistent）</li>
<li>临时性节点（Ephemeral）</li>
<li>顺序性节点（Sequential)）</li>
</ul>
<p>在开发中在创建节点的时候通过组合可以生成以下四种节点类型：持久节点、持久顺序节点、临时节 点、临时顺序节点。不同类型的节点则会有不同的生命周期 </p>
<p><strong>持久节点：</strong></p>
<p>是Zookeeper中最常见的一种节点类型，所谓持久节点，就是指节点被创建后会一直存在服 务器，直到删除操作主动清除 </p>
<p><strong>持久顺序节点：</strong></p>
<p>就是有顺序的持久节点，节点特性和持久节点是一样的，只是额外特性表现在顺序上。 顺序特性实质是在创建节点的时候，会在节点名后面加上一个数字后缀，来表示其顺序。</p>
<p><strong>临时节点：</strong></p>
<p>就是会被自动清理掉的节点，它的生命周期和客户端会话绑在一起，客户端会话结束，节点会被删除掉。与持久性节点不同的是，<strong>临时节点不能创建子节点</strong>。</p>
<p><strong>临时顺序节点</strong></p>
<p>就是有顺序的临时节点，和持久顺序节点相同，在其创建的时候会在名字后面加上数字 后缀。</p>
<p><strong>事务ID</strong> </p>
<p>首先，先了解，事务是对物理和抽象的应用状态上的操作集合。往往在现在的概念中，狭义上的事务通 常指的是数据库事务，一般包含了一系列对数据库有序的读写操作，这些数据库事务具有所谓的ACID特 性，即原子性(Atomic)、一致性(Consistency)、隔离性(Isolation)和持久性(Durability)。</p>
<p>而在ZooKeeper中，事务是指能够改变ZooKeeper服务器状态的操作，我们也称之为事务操作或更新操作，一般包括数据节点创建与删除、数据节点内容更新等操作。对于每一个事务请求，ZooKeeper都会 为其分配一个全局唯一的事务ID，用 **ZXID **来表示，通常是一个64位的数字。每一个ZXID对应一次更新操作，从这些ZXID中可以间接地识别出ZooKeeper处理这些更新操作请求的全局顺序</p>
<h3 id="4-2-ZNode的状态信息"><a href="#4-2-ZNode的状态信息" class="headerlink" title="4.2 ZNode的状态信息"></a>4.2 ZNode的状态信息</h3><p>我先来写几个命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根目录的所有节点</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] <span class="built_in">ls</span> /</span><br><span class="line">[dubbo, <span class="built_in">test</span>, zookeeper]</span><br><span class="line"></span><br><span class="line"><span class="comment"># get 命令 来获取节点内容</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] get /test</span><br><span class="line">hope666</span><br><span class="line"></span><br><span class="line"><span class="comment"># stat 命令 来获取节点状态信息</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] <span class="built_in">stat</span> /test</span><br><span class="line">cZxid = 0x5d</span><br><span class="line">ctime = Wed Dec 09 13:46:38 GMT+08:00 2020</span><br><span class="line">mZxid = 0x5e</span><br><span class="line">mtime = Wed Dec 09 13:47:01 GMT+08:00 2020</span><br><span class="line">pZxid = 0x61</span><br><span class="line">cversion = 2</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 7</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>



<p>整个ZNode节点内容包括两部分：节点数据内容和节点状态信息。那么这些状态信息都有什么含义呢？</p>
<ul>
<li>cZxid Create ZXID：表示节点被创建时的事务ID</li>
<li>ctime Create Time：表示节点创建时间。</li>
<li>mZxid Modified ZXID：表示节点最后一次被修改时的事务ID。</li>
<li>mtime Modified Time：表示节点最后一次被修改的时间。</li>
<li>pZxid：表示该节点的子节点列表最后一次被修改时的事务ID。只有子节点列表变更才会更新pZxid,子节点内容变更不会更新。</li>
<li>eversion：表示子节点的版本号。</li>
<li>dataVersion： 表不内容版本号。</li>
<li>aclVersion： 标识 acl 版本</li>
<li>ephemeralOwner：表示创建该临时节点时的会话sessionID，如果是持久性节点那么值为0 dataLength表示数据长度。</li>
<li>numchildren：表示直系子节点数。</li>
</ul>
<h3 id="4-3-Watcher"><a href="#4-3-Watcher" class="headerlink" title="4.3 Watcher"></a>4.3 Watcher</h3><p><strong>Watcher 数据变更通知</strong></p>
<p>Zookeeper使用Watcher机制实现分布式数据的发布/订阅功能 —个典型的发布/订阅模型系统定义了一种一对多的订阅关系，能够让多个订阅者同时监听某一个主题 对象，当这个主题对象自身状态变化时，会通知所有订阅者，使它们能够做出相应的处理。</p>
<p>在ZooKeeper中，引入了 Watcher机制来实现这种分布式的通知功能。ZooKeeper允许客户端向服务 端注册一个Watcher监听，当服务端的一些指定事件触发了这个Watche r,那么就会向指定客户端发 送一个事件通知来实现分布式的通知功能。</p>
<p>整个Watcher注册与通知过程如图所示。</p>
<p><img src="https://hopestation.top/upload/2020/12/zk13-678eeb5b950741898fb530c7532372a0.png" alt="zk13.png"></p>
<p>Zookeeper的Watcher机制主要包括客户端线程、客户端WatcherManager、Zookeeper服务器三部 分。</p>
<p>具体工作流程为：客户端在向Zookee per服务器注册的同时，会将Watcher对象存储在客户端的 WatcherManager当中。当Zookeeper服务器触发Watcher事件后，会向客户端发送通知，客户端线程 从WatcherManager中取出对应的Watcher对象来执行回调逻辑。</p>
<blockquote>
<p>这种监听机制，把压力分散在了每一个服务器上，去监听这个zookeeper中心。监听数据变化</p>
</blockquote>
<h3 id="4-4-ACL"><a href="#4-4-ACL" class="headerlink" title="4.4 ACL"></a>4.4 ACL</h3><p><strong>ACL–保障数据的安全</strong></p>
<p>Zookee per作为一个分布式协调框架，其内部存储了分布式系统运行时状态的元数据，这些元数据会直 接影响基于Zookee per进行构造的分布式系统的运行状态，因此，如何保障系统中数据的安全，从而避 免因误操作所带来的数据随意变更而导致的数据库异常十分重要，在Zookee per中，提供了一套完善的 ACL (Access Control List)权限控制机制来保障数据的安全。</p>
<p>我们可以从三个方面来理解ACL机制：**权限模式(Scheme)、授权对象(ID)、权限 (Permission)，通常使用<code>scheme: id : permission</code>**来标识一个有效的ACL信息。</p>
<p><strong>权限模式：Scheme</strong></p>
<p><strong>权限模式</strong>用来确定权限验证过程中使用的检验策略，有如下四种模式:</p>
<p><strong>ip</strong></p>
<p>IP模式就是通过IP地址粒度来进行权限控制，如”i p：192.168.0.110”表示权限控制针对该IP地址， 同时IP模式可以支持按照网段方式进行配置，如”ip ：192.168.0.1/24”表示针对192.168.0.*这个网段 进行权限控制。</p>
<p><strong>Digest</strong></p>
<p>Digest是最常用的权限控制模式，要更符合我们对权限控制的认识，其使</p>
<p>用”username: password”形式的权限标识来进行权限配置，便于区分不同应用来进行权限控制。</p>
<p>当我们通过”username:password”形式配置了权限标识后，Zookeeper会先后对其进行SHA-1加密 和BASE64编码。</p>
<p><strong>World</strong></p>
<p>World是一种最开放的权限控制模式，这种权限控制方式几乎没有任何作用，数据节点的访问权限 对所有用户开放，即所有用户都可以在不进行任何权限校验的情况下操作ZooKee per上的数据。 另外，World模式也可以看作是一种特殊的Digest模式，它只有一个权限标识，即”world： anyone”。</p>
<p><strong>Super</strong></p>
<p>Super模式，顾名思义就是超级用户的意思，也是一种特殊的Digest模式。在Super模式下，超级 用户可以对任意ZooKee per上的数据节点进行任何操作。</p>
<p><strong>授权对象：ID</strong></p>
<p>授权对象指的是权限赋予的用户或一个指定实体，例如IP地址或是机器等。在不同的权限模式下，授 权对象是不同的，表中列出了各个权限模式和授权对象之间的对应关系。</p>
<p><img src="https://hopestation.top/upload/2020/12/zk14-a5eff3d3afb54e9c985a9fdba4733865.png" alt="zk14.png"></p>
<p><strong>权限</strong></p>
<p> 权限就是指那些通过权限检查后可以被允许执行的操作。在ZooKee per中，所有对数据的操作权限分为 以下五大类： </p>
<ul>
<li><p>CREATE (C)：数据节点的创建权限，允许授权对象在该数据节点下创建子节点。</p>
</li>
<li><p>DELETE (D)： 子节点的删除权限，允许授权对象删除该数据节点的子节点。</p>
</li>
<li><p>READ (R):数据节点的读取权限，允 许授权对象访问该数据节点并读取其数据内容或子节点列表等。</p>
</li>
<li><p>WRITE (W):数据节点的更新权 限，允许授权对象对该数据节点进行更新操作。</p>
</li>
<li><p>ADMIN (A):数据节点的管理权限，允许授权对象 对该数据节点进行ACL相关的设置操作。</p>
</li>
</ul>
<h2 id="5-命令"><a href="#5-命令" class="headerlink" title="5. 命令"></a>5. 命令</h2><p>现在已经搭建起了一个能够正常运行的zookee per服务了，所以接下来，就是来借助客户端来对 zookee per的数据节点进行操作 首先，进入到zookee per的bin目录之后 通过zkClient进入zookee per客户端命令行</p>
<p>./zkcli.sh 连接本地的zookee per服务器</p>
<p>./zkCli.sh -server ip:p ort连接指定的服务器</p>
<p>连接成功之后，系统会输出Zookee per的相关环境及配置信息等信息。输入hel p之后，屏幕会输出可用 的Zookeeper命令，如下图所示</p>
<p><strong>1、创建节点</strong> </p>
<p>使用Create命令，可以•创建一个Zookee per节点，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create [-s][-e] path data acl</span><br></pre></td></tr></table></figure>

<p>其中，-s或-e分别指定节点特性，顺序或临时节点，若不指定，则创建持久节点；acl用来进行权限控制。</p>
<p><strong>2、创建顺序节点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s /zk-test 123</span><br></pre></td></tr></table></figure>

<p>执行完后，就在根节点下创建了一个叫做/zk-test的节点，该节点内容就是123，同时可以看到创建的 zk-test节点后面添加了一串数字以示区别</p>
<p><strong>3、创建临时节点</strong></p>
<p>使用create -e /zk-temp 123命令创建zk-te mp临时节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e /zk-temp 123</span><br></pre></td></tr></table></figure>

<p>临时节点在客户端会话结束后，就会自动删除，下面使用****quit****命令退出客户端</p>
<p>再次使用客户端连接服务端，并使用ls /命令查看根目录下的节点</p>
<p>可以看到根目录下已经不存在zk-tem P临时节点了</p>
<p><strong>4、创建永久节点</strong></p>
<p>使用 <strong>create /zk-p ermanent 123</strong> 命令创建 zk- permanent 永久节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /zk-permanent 123</span><br></pre></td></tr></table></figure>

<p>可以看到永久节点不同于顺序节点，不会自动在后面添加一串数字</p>
<p><strong>5、读取节点</strong> </p>
<p>与读取相关的命令有ls命令和get命令 ls命令可以列出Zookee per指定节点下的所有子节点，但只能查看指定节点下的第一级的所有子节点;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls path</span><br></pre></td></tr></table></figure>

<p>其中，path表示的是指定数据节点的节点路径 get命令可以获取Zookee per指定节点的数据内容和属性信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get path</span><br></pre></td></tr></table></figure>

<p>若获取根节点下面的所有子节点，使用<em><strong>*ls*</strong></em> ****/****命令即可</p>
<p>若想获取/zk-permanent的数据内容和属性，可使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /zk-permanent</span><br></pre></td></tr></table></figure>

<p>我们可以看到，第一行是节点/zk-permanent的数据内容，其他几行则是创建该 节点的事务ID (cZxid)、最后一次更新该节点的事务ID (mZxid)和最后一次更新该节点的时间(mtime)等属性信息</p>
<p><strong>6、更新节点</strong></p>
<p> 使用set命令，可以更新指定节点的数据内容，用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set path data [version]</span><br></pre></td></tr></table></figure>

<p>其中，data就是要更新的新内容，version表示数据版本，在zookeeper中，节点的数据是有版本概 念的，这个参数用于指定本次更新操作是基于Znode的哪一个数据版本进行的，如将/zk-P ermanent节 点的数据更新为456,可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set /zk-permanent 456</span><br></pre></td></tr></table></figure>

<p>现在dataVersion已经变为1 了，表示进行了更新</p>
<p><strong>7、删除节点</strong></p>
<p>使用delete命令可以删除Zookee per上的指定节点，用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete path [version]</span><br></pre></td></tr></table></figure>

<p>其中version也是表示数据版本，使用<strong>delete /zk- permanent</strong>命令即可删除/zk-p ermanent节点</p>
<p>值得注意的是，<strong>若删除节点存在子节点，那么无法删除 该节点，必须先删除子节点，再删除父节点</strong></p>
<h2 id="6-API"><a href="#6-API" class="headerlink" title="6. API"></a>6. API</h2><p>也就是通过JAVA来操作我们的Zookeeper，而不是直接通过Zookeeper客户端的命令行。</p>
<p>可以参考这篇文章：<a target="_blank" rel="noopener" href="https://www.yuque.com/realskrman/bi4s0n/sf8hyq#VvaWB">https://www.yuque.com/realskrman/bi4s0n/sf8hyq#VvaWB</a></p>
<h2 id="7-服务器角色"><a href="#7-服务器角色" class="headerlink" title="7. 服务器角色"></a>7. 服务器角色</h2><h3 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h3><p>Leader服务器是Zookee per集群工作的核心，其主要工作有以下两个:</p>
<p>(1) 事务请求的唯一调度和处理者，保证集群事务处理的顺序性。</p>
<p>(2) 集群内部各服务器的调度者。</p>
<p>\1. 请求处理链</p>
<p>使用责任链来处理每个客户端的请求是Zookeeper的特色，Leader服务器的请求处理链如下:</p>
<p><img src="https://hopestation.top/upload/2020/12/zk15-9c0facaf2e564ce9a573eb23b41c805f.png" alt="zk15.png"></p>
<p>可以看到，从 P re pRequest Processor 到 FinalRequest Processor 前后一共 7个请求处理器组成 了 leader 服务器的请求处理链</p>
<p>(1) Prep Request Processor。请求预处理器，也是leader服务器中的第一个请求处理器。在Zookee per 中，那些会改变服务器状态的请求称为事务请求(创建节点、更新数据、删除节点、创建会话等)， Prep Request Process。r能够识别出当前客户端请求是否是事务请求。对于事务请求，</p>
<p>PrepRequestProcess。r处理器会对其进行一系列预处理，如创建请求事务头、事务体、会话检查、ACL 检查和版本检查等。</p>
<p>(2) ProposalRequestProcessor。事务投票处理器。也是Leader服务器事务处理流程的发起者，对 于非事务性请求，Propo salRequest Process。r会直接将请求转发到Commit Processor处理器，不再做 任何处理，而对于事务性请求，处理将请求转发到Commit Processor外，还会根据请求类型创建对应的 Pro po sal提议，并发送绐所有的Follower服务器来发起一次集群内的事务投票。同时， Propo salRequest Processor还会将事务请求交付绐SyncRequest Processor进行事务日志的记录。</p>
<p>(3) SyncRequest Processor。事务日志记录处理器。用来将事务请求记录到事务日志文件中，同时 会触发Zookee per进行数据快照。</p>
<p>(4) AckRequestProcessor。负责在SyncRequestProcessor完成事务日志记录后，向Proposal的投 票收集器发送ACK反馈，以通知投票收集器当前服务器已经完成了对该Proposal的事务日志记录。</p>
<p>(5) Commit Processor。事务提交处理器。对于非事务请求，该处理器会直接将其交付绐下一级处 理器处理；对于事务请求，其会等待集群内针对Prop osa l的投票直到该Prop osal可被提交，利用 Commit Processor，每个服务器都可以很好地控制对事务请求的顺序处理。</p>
<p>(6) ToBeCommit Processor。该处理器有一个toBeA pp lied队列，用来存储那些已经被</p>
<p>Commit Processor处理过的可被提交的P ro posal。其会将这些请求交付绐FinalRequest Processor处理 器处理，待其处理完后，再将其从toBeA PP lied队列中移除。</p>
<p>(7) FinalRequest Processor。用来进行客户端请求返回之前的操作，包括创建客户端请求的响应, 针对事务请求，该处理器还会负责将事务应用到内存数据库中。</p>
<h3 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h3><p>Follower服务器是Zookee per集群状态中的跟随者，其主要工作有以下三个:</p>
<p>(1)处理客户端非事务性请求(读取数据)，转发事务请求绐Leader服务器。</p>
<p>(1) 参与事务请求P ro po sa l的投票。</p>
<p>(2) 参与Leader选举投票。</p>
<p>和leader—样，Follower也采用了责任链模式组装的请求处理链来处理每一个客户端请求，由于不 需要对事务请求的投票处理，因此Follower的请求处理链会相对简单，其处理链如下</p>
<p><img src="https://hopestation.top/upload/2020/12/zk16-ec01902ec9ec480fa590415a9f2668b7.png" alt="zk16.png"></p>
<p>和Leader服务器的请求处理链最大的不同点在于，Follower服务器的第一个处理器换成了 FollowerRequest Processor处理器，同时由于不需要处理事务请求的投票，因此也没有了 P ro po salRequest Processor 处理器。</p>
<p>  (1) FollowerRequestProcessor 其用作识别当前请求是否是事务请求，若是，那么Follower就会将该请求转发绐Leader服务器， Leader服务器在接收到这个事务请求后，就会将其提交到请求处理链，按照正常事务请求进行处理。</p>
<p>(2) SendAckRequestProcessor 其承担了事务日志记录反馈的角色，在完成事务日志记录后，会向Leader服务器发送ACK消息以表明自 身完成了事务日志的记录工作</p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>Observer是ZooKee per自3.3.0版本开始引入的一个全新的服务器角色。从字面意思看，该服务器充当 了一个观察者的角色其观察ZooKee per集群的最新状态变化并将这些状态变更同步过来。</p>
<p>Observer服务器在工作原理上和Follower基本是一致的，对于非事务请求，都可以进行独立的处理，而 对于事务请求，则会转发绐Leader服务器进行处理。和Follower唯一的区别在于，Observer不参与任 何形式的投票，包括事务请求Proposal的投票和Leader选举投票。简单地讲，Observer服务器只提供 非事务服务，通常用于在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</p>
<p>另外，Observer的请求处理链路和Follower服务器也非常相近,其处理链如下</p>
<p><img src="https://hopestation.top/upload/2020/12/zk17-7c563f2e61be41219cd7fefea85d7e62.png" alt="zk17.png"></p>
<p>另外需要注意的一点是，虽然在图中可以看到，Observer服务器在初始化阶段会将</p>
<p>SyncRequestProcess。r处理器也组装上去，但是在实际运行过程中，Leader服务器不会将事务请求的 投票发送绐Observer服务器。</p>
<h2 id="8-选举机制"><a href="#8-选举机制" class="headerlink" title="8. 选举机制"></a>8. 选举机制</h2><p><strong>1.初始化Leader选举。</strong></p>
<p>集群模式特有，Zookeeper首先会根据自身的服务器ID(SID)、最新的</p>
<p>ZXID (lastLoggedZxid)和当前的服务器epoch (currentEpoch)来生成一个初始化投票，在 初始化过程中，每个服务器都会给自己投票。然后，根据zoo.cfg的配置，创建相应Leader选举算法 实现，Zookeeper提供了三种默认算法(LeaderElection、AuthFastLeaderElection、 FastLeaderElection),可通过zoo.cfg中的electionAlg属性来指定，但现只支持 FastLeaderElection选举算法。在初始化阶段，Zookeeper会创建Leader选举所需的网络I/O层 QuorumCnxManager,同时启动对Leader选举端口的监听，等待集群中其他服务器创建连接。</p>
<p><strong>2.注册JMX服务。</strong></p>
<p><strong>3</strong> <strong>检测当前服务器状态</strong></p>
<p>运行期间，Quorum Peer会不断检测当前服务器状态。在正常情况下，Zookee per服务器的状态 在 LOOKING、LEADING、FOLLOWING/OBSERVING 之间进行切换。在启动阶段，Quorum Peer 的初始 状态是LOOKING,因此开始进行Leader选举。</p>
<p><strong>4. Leader 选举</strong></p>
<p>ZooKee per的Leader选举过程，简单地讲，就是一个集群中所有的机器相互之间进行一系列投 票，选举产生最合适的机器成为Leader,同时其余机器成为Follower或是Observer的集群机器角 色初始化过程。关于Leader选举算法，简而言之，就是集群中哪个机器处理的数据越新(通常我们根 据每个服务器处理过的最大ZXID来比较确定其数据是否更新)，其越有可能成为Leader。当然，如 果集群中的所有机器处理的ZXID—致的话，那么SID最大的服务器成为Leader，其余机器称为 Follower 和 Observer</p>
<h2 id="9-参考文献"><a href="#9-参考文献" class="headerlink" title="9 参考文献"></a>9 参考文献</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.yuque.com/realskrman/bi4s0n/wrbzgy">https://www.yuque.com/realskrman/bi4s0n/wrbzgy</a> (☆☆☆☆☆)<br>语雀 比较详细 （本文大部分参考了此本章）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ultranms/p/9585191.html">https://www.cnblogs.com/ultranms/p/9585191.html</a>  (☆☆☆) 比较详细，目前理解有点难</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mindzone/p/13448950.html">https://www.cnblogs.com/mindzone/p/13448950.html</a>  (☆☆) 比较基础简洁</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/12/08/Dubbo%20+%20Zookeeper-dubbozookeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/08/Dubbo%20+%20Zookeeper-dubbozookeeper/" class="post-title-link" itemprop="url">Dubbo + Zookeeper</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-08 17:26:26" itemprop="dateCreated datePublished" datetime="2020-12-08T17:26:26+08:00">2020-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:43:16" itemprop="dateModified" datetime="2022-09-22T22:43:16+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dubbo-Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Dubbo + Zookeeper</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><p>[TOC]</p>
<hr>
<blockquote>
<p>本文可能有点长，之后可能会像其他文章一样做个拆分</p>
</blockquote>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>网站应用的演进：随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p>
<p><img src="http://dubbo.apache.org/imgs/user/dubbo-architecture-roadmap.jpg" alt="image"></p>
<h3 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a>单一应用架构</h3><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<h3 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h3><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<h3 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h3><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<h3 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h3><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h2 id="2-Zookeeper安装"><a href="#2-Zookeeper安装" class="headerlink" title="2. Zookeeper安装"></a>2. Zookeeper安装</h2><blockquote>
<p>介绍的是Windows系统的安装。</p>
</blockquote>
<h3 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h3><p>Dubbo官网<strong>推荐使用</strong>Zookeeper来作为注册中心。先来安装一下Zookeeper</p>
<p><img src="https://hopestation.top/upload/2020/12/zk01-45a4953ba8a94288956534b951cfbd01.png" alt="zk01"></p>
<p>点击完 Download后，选择稳定并且最新的版本下载</p>
<p><img src="https://hopestation.top/upload/2020/12/zk02-8e8cbc4c43744ca784fc170344ba4558.png" alt="zk02"></p>
<h3 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2 解压"></a>2.2 解压</h3><p>下载的是一个压缩包，解压后。在该目录下新建一个<code>data</code>文件夹</p>
<p><img src="https://hopestation.top/upload/2020/12/zk04-4d9d7003a1234061b283de372af0c9c7.png" alt="zk04"></p>
<p>然后在<code>conf</code>目录下，将<code>zoo_sample.cfg</code>，复制一份命名为<code>zoo.cfg</code></p>
<p><img src="https://hopestation.top/upload/2020/12/zk03-ccb458291c4f49d6833f3462a9d53d70.png" alt="zk03"></p>
<p>修改<code>zoo.cfg</code>中<code>dataDir</code>的内容为刚刚建立的文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line">dataDir=../data</span><br></pre></td></tr></table></figure>

<h3 id="2-3-运行"><a href="#2-3-运行" class="headerlink" title="2.3 运行"></a>2.3 运行</h3><ol>
<li>在解压目录中的bin目录下运行<code>zkServer.cmd</code>，Zookeeper服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\apache-zookeeper-3.6.2-bin\apache-zookeeper-3.6.2-bin\bin&gt;zkServer.cmd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要安装JDK并且环境变量里有<code>JAVA_HOME</code>，不然会提示<code>Java home is not set</code> </p>
</blockquote>
<ol start="2">
<li>在解压目录中的bin目录下运行<code>zkCli.cmd</code>，Zookeeper客户端</li>
</ol>
<p>输入点命令测试一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:None path:null</span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] get /</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] <span class="built_in">ls</span> /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e /hope 123456</span><br><span class="line">Created /hope</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> [-s] [-w] [-R] path</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] <span class="built_in">ls</span> /</span><br><span class="line">[hope, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] get /hope</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>



<h2 id="3-HelloWorld"><a href="#3-HelloWorld" class="headerlink" title="3. HelloWorld"></a>3. HelloWorld</h2><blockquote>
<p>编写一个Dubbo的服务调用例子，此处参考了<a target="_blank" rel="noopener" href="https://blog.csdn.net/hemin1003/article/details/96483573">此篇文章</a></p>
</blockquote>
<p>pom</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-1-服务提供者"><a href="#3-1-服务提供者" class="headerlink" title="3.1 服务提供者"></a>3.1 服务提供者</h3><h4 id="3-1-1-提供者-Service"><a href="#3-1-1-提供者-Service" class="headerlink" title="3.1.1 提供者 Service"></a>3.1.1 提供者 Service</h4><p>提供的service方法</p>
<ul>
<li><code>DemoService</code>  接口</li>
<li><code>DemoServiceImpl</code>  实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">package</span> com.md.demo.service;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DemoService</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Welcome to Minbo&#x27;s Dubbo demo, Hello &quot;</span> + name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">package</span> com.md.demo.service;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DemoService</span> &#123;</span><br><span class="line">	String <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-提供者-Xml"><a href="#3-1-2-提供者-Xml" class="headerlink" title="3.1.2 提供者 Xml"></a>3.1.2 提供者 Xml</h4><p>编写<code>src\main\resources\providers.xml</code>文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 配置可参考 http://dubbo.io/User+Guide-zh.htm --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 服务提供方应用名，用于计算依赖关系 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;spring-boot2-dubbo-provider&quot;</span> <span class="attr">owner</span>=<span class="string">&quot;spring-boot2-dubbo-provider&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 定义 zookeeper 注册中心地址及协议 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">address</span>=<span class="string">&quot;localhost:2181&quot;</span> <span class="attr">client</span>=<span class="string">&quot;zkclient&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 定义 Dubbo 协议名称及使用的端口，dubbo 协议缺省端口为 20880，如果配置为 -1 或者没有配置 port，则会分配一个没有被占用的端口 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.md.demo.service.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 和本地 bean 一样实现服务 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.md.demo.service.DemoServiceImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-服务消费者"><a href="#3-2-服务消费者" class="headerlink" title="3.2 服务消费者"></a>3.2 服务消费者</h3><h4 id="3-2-1-调用提供者的Service"><a href="#3-2-1-调用提供者的Service" class="headerlink" title="3.2.1 调用提供者的Service"></a>3.2.1 调用提供者的Service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试用的 Controller 类；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 测试 JSON 接口；</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name 名字</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> JsonResult <span class="title function_">testJson</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//调用 服务提供者的方法</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.demoService.sayHello(name);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(ResultCode.SUCCESS, result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-2-消费者-Xml"><a href="#3-2-2-消费者-Xml" class="headerlink" title="3.2.2 消费者 Xml"></a>3.2.2 消费者 Xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">   <span class="comment">&lt;!-- 配置可参考 http://dubbo.io/User+Guide-zh.htm --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;spring-boot2-dubbo-consumer&quot;</span> <span class="attr">owner</span>=<span class="string">&quot;spring-boot2-dubbo-consumer&quot;</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">&lt;!-- 定义 zookeeper 注册中心地址及协议 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">address</span>=<span class="string">&quot;localhost:2181&quot;</span> <span class="attr">client</span>=<span class="string">&quot;zkclient&quot;</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">&lt;!-- 生成远程服务代理，可以和本地 bean 一样使用 demoService --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.md.demo.service.DemoService&quot;</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="4-Dubbo-Admin"><a href="#4-Dubbo-Admin" class="headerlink" title="4. Dubbo-Admin"></a>4. Dubbo-Admin</h2><p>dubbo-admin 是 dubbo的控制台，具有服务查询、服务治理的功能。（感觉类似Eureka的功能界面）</p>
<blockquote>
<p>假如上面的服务提供者还在运行，这里会显示那个服务</p>
</blockquote>
<p><img src="https://hopestation.top/upload/2020/12/dz03-ce0506b64c624112bd2a2e2d91234c89.png" alt="dz03"></p>
<h3 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h3><blockquote>
<p>这里是配合我们单机的Zookeeper来，认识一下Dubbo-admin的界面</p>
</blockquote>
<h4 id="4-1-1-下载"><a href="#4-1-1-下载" class="headerlink" title="4.1.1 下载"></a>4.1.1 下载</h4><p>​    在GitHub上直接搜<code>dubbo admin</code>即可，是Apache的项目，一般第一个就是。然后下载，解压</p>
<p><img src="https://hopestation.top/upload/2020/12/dz01-4db28b69a93b4d0c9f6c4da12d598254.png" alt="dz01"></p>
<h4 id="4-1-2-修改配置"><a href="#4-1-2-修改配置" class="headerlink" title="4.1.2 修改配置"></a>4.1.2 修改配置</h4><p>用IDEA打开文件，先修改一些配置</p>
<p><img src="https://hopestation.top/upload/2020/12/dz02-71995ad5a9a14025a4780e4e59792d79.png" alt="dz02"></p>
<ol>
<li>dubbo-admin-develop\dubbo-admin-server\src\main\resources\application.properties</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centers in dubbo2.7</span></span><br><span class="line"><span class="comment">#-------- 确你的Zookeeper端口是否是2181（默认是的）---------</span></span><br><span class="line"><span class="string">admin.registry.address=zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="string">admin.config-center=zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="string">admin.metadata-report.address=zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="comment"># Dubbo-Admin控制台的登录账号和密码</span></span><br><span class="line"><span class="string">admin.root.user.name=root</span></span><br><span class="line"><span class="string">admin.root.user.password=root</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#compress</span></span><br><span class="line"><span class="string">server.compression.enabled=true</span></span><br><span class="line"><span class="string">server.compression.mime-types=text/css,text/javascript,application/javascript</span></span><br><span class="line"><span class="string">server.compression.min-response-size=10240</span></span><br><span class="line"><span class="comment">#-------增加这句话，来设置dubbo-admin后台的端口是8051</span></span><br><span class="line"><span class="comment">#（默认是8080容易端口占用，设置一个没有被使用的端口即可）</span></span><br><span class="line"><span class="string">server.port=8051</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>dubbo-admin-develop\dubbo-admin-ui\vue.config.js</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const path = require(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  outputDir: <span class="string">&quot;target/dist&quot;</span>,</span><br><span class="line">  lintOnSave: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    //-----这个端口应该是随便的，注意也不要使用被占用的端口就行----</span><br><span class="line">    port: 8050,  </span><br><span class="line">    historyApiFallback: &#123;</span><br><span class="line">      rewrites: [</span><br><span class="line">        &#123;from: /.*/, to: path.posix.join(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)&#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    publicPath: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">&#x27;/&#x27;</span>: &#123;</span><br><span class="line">        //-----代理目标：注意与application.properties的server.port保持一致----</span><br><span class="line">        target: <span class="string">&#x27;http://localhost:8051/&#x27;</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">&#x27;^/&#x27;</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<h3 id="4-2-运行"><a href="#4-2-运行" class="headerlink" title="4.2 运行"></a>4.2 运行</h3><h4 id="4-2-1-启动Zookeeper"><a href="#4-2-1-启动Zookeeper" class="headerlink" title="4.2.1 启动Zookeeper"></a>4.2.1 启动Zookeeper</h4><p>在上面zookeeper的解压目录中的<code>bin</code>下运行：<strong>zkServer.cmd</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\apache-zookeeper-3.6.2-bin\apache-zookeeper-3.6.2-bin\bin&gt;zkServer.cmd</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-启动Dubbo-Admin"><a href="#4-2-2-启动Dubbo-Admin" class="headerlink" title="4.2.2 启动Dubbo-Admin"></a>4.2.2 启动Dubbo-Admin</h4><blockquote>
<p>新版的是前后端分离架构的。所以前端后端需要分开来运行</p>
</blockquote>
<ol>
<li><p>运行前端：在IDEA的命令行或者本地命令行输入 <code>npm run dev</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意是在 dubbo-admin-ui 目录下运行</span></span><br><span class="line">E:\dubbo-admin-develop (1)\dubbo-admin-develop\dubbo-admin-ui&gt;npm run dev</span><br></pre></td></tr></table></figure></li>
<li><p>运行后端<br>dubbo-admin-develop\dubbo-admin-server\src\main\java\org\apache\dubbo\admin\DubboAdminApplication.java</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#错误结果：</span></span><br><span class="line"><span class="comment">#1.注意先启动Zookeeper，不然会报错 KeeperErrorCode = ConnectionLoss</span></span><br><span class="line">org.apache.curator.CuratorConnectionLossException: KeeperErrorCode = ConnectionLoss</span><br><span class="line"><span class="comment">#2.端口占用 主要端口占用问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#正常结果</span></span><br><span class="line">Tomcat started on port(s): 8051 (http) with context path <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>4.2.3 访问 <a target="_blank" rel="noopener" href="http://localhost:8050/">http://localhost:8050/</a></p>
<p><img src="https://hopestation.top/upload/2020/12/dz04-7565ee18695040eb919edfd4b7450148.png" alt="dz04"></p>
<h2 id="5-Dubbo-Monitor"><a href="#5-Dubbo-Monitor" class="headerlink" title="5. Dubbo-Monitor"></a>5. Dubbo-Monitor</h2><blockquote>
<p>参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yz357823669/article/details/80505642">https://blog.csdn.net/yz357823669/article/details/80505642</a></p>
</blockquote>
<p>Dubbo-Monitor 主要用来统计服务的调用次数和调用时间，服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心，监控中心则使用数据绘制图表来显示。<br>服务消费方和提供方需要显示开启 Monitor。<br>如果使用 Spring 配置的服务消费方和提供方，则需要在对应 XML 添加下面配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 protocol 为“registry”，表示服务提供方和消费方从服务注册中心发现监控中心（Monitor）地址。<br>如果使用的 Dubbo API 方式需要首先创建一个 MonitorConfig 对象。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MonitorConfig monitorConfig = new MonitorConfig();</span><br><span class="line">monitorConfig.setProtocol(&quot;registry&quot;);</span><br></pre></td></tr></table></figure>

<p>然后调用 <code>reference.setMonitor(monitorConfig);</code> 设置到消费配置对象里面。<br>同样我们下载dubbo源码之后解压打包，这里提供下载<a target="_blank" rel="noopener" href="https://download.csdn.net/download/yz357823669/10436895">点我下载</a><br>解压 dubbo-monitor-simple-2.5.10-assembly.tar.gz，进入 dubbo-monitor-simple-2.5.10/conf/ 目录修改 <code>dubbo.properties</code></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.container</span>=<span class="string">log4j,spring,registry,jetty</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">simple-monitor</span></span><br><span class="line"><span class="attr">dubbo.application.owner</span>=<span class="string"></span></span><br><span class="line"><span class="comment">#dubbo.registry.address=multicast://224.5.6.7:1234</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="comment">#dubbo.registry.address=redis://127.0.0.1:6379</span></span><br><span class="line"><span class="comment">#dubbo.registry.address=dubbo://127.0.0.1:9090</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">7070</span></span><br><span class="line"><span class="attr">dubbo.jetty.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="attr">dubbo.jetty.directory</span>=<span class="string">$&#123;user.home&#125;/monitor</span></span><br><span class="line"><span class="attr">dubbo.charts.directory</span>=<span class="string">$&#123;dubbo.jetty.directory&#125;/charts</span></span><br><span class="line"><span class="attr">dubbo.statistics.directory</span>=<span class="string">$&#123;user.home&#125;/monitor/statistics</span></span><br><span class="line"><span class="attr">dubbo.log4j.file</span>=<span class="string">logs/dubbo-monitor-simple.log</span></span><br><span class="line"><span class="attr">dubbo.log4j.level</span>=<span class="string">WARN</span></span><br></pre></td></tr></table></figure>

<p>其中 dubbo.registry.address=zookeeper://127.0.0.1:2181 设置注册中心地址，这里设置为 ZooKeeper 的地址。<br>dubbo.protocol.port=7070，是 Monitor 提供的远程服务监听端口，服务提供者和消费者会调用这个端口提供的服务，发送统计信息到 Monitor。<br>dubbo.charts.directory 和 dubbo.statistics.directory 为 Monitor 本地存放的监控数据文件的位置。<br>dubbo.jetty.port=8081，设置 Jetty 容器的监听地址，类似于 Tomcat 的8080端口，这里设置为8081。<br>然后进入 dubbo-monitor-simple-2.5.10/bin，执行 <code>start.bat</code> 启动 Monitor：<br><img src="https://img-blog.csdn.net/20180530113841395?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6MzU3ODIzNjY5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>至此 Monitor 启动了，访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:8081/">http://127.0.0.1:8081/</a> 会出现下面界面：<br><img src="https://img-blog.csdn.net/20180530113918121?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6MzU3ODIzNjY5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>然后我们就可以使用监控平台做一些事情了。比如服务查看,应用程序查看,调用情况统计<br><strong>注</strong>： Dubbo-Monitor 也不是使用 Dubbo 搭建分布式系统必须的组件，但是它用来统计服务的调用次调和调用时间的监控中心，这些数据有助于系统运维和调优。</p>
<h2 id="6-常用配置"><a href="#6-常用配置" class="headerlink" title="6. 常用配置"></a>6. 常用配置</h2><blockquote>
<p>参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yz357823669/article/details/83591507">https://blog.csdn.net/yz357823669/article/details/83591507</a></p>
</blockquote>
<p>之前我们简单介绍了dubbo配置服务提供者、消费者以及管理平台监控平台，接下来我们再说一下dubbo的其他配置。</p>
<h3 id="6-1-配置策略"><a href="#6-1-配置策略" class="headerlink" title="6.1 配置策略"></a>6.1 配置策略</h3><h4 id="6-1-1-属性配置"><a href="#6-1-1-属性配置" class="headerlink" title="6.1.1 属性配置"></a>6.1.1 属性配置</h4><p>dubbo可以在<strong>JVM 启动参数</strong>、<strong>dubboXML</strong>、<strong>dubbo.properties</strong> 三个地方配置相关属性,这里我们以端口为例.</p>
<ul>
<li>JVM 启动参数<br>我们可以在启动项目时配置VM参数<br><img src="https://img-blog.csdnimg.cn/20181101085628615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6MzU3ODIzNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Ddubbo.protocol.port</span>=<span class="string">20883</span></span><br></pre></td></tr></table></figure>

<ul>
<li>dubboXML</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20882&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:protocol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>dubbo.properties</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">20881</span></span><br></pre></td></tr></table></figure>

<p><strong>覆盖策略</strong><br><img src="https://img-blog.csdnimg.cn/20181031220111268.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6MzU3ODIzNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</p>
<p>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</p>
<p>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>
<h4 id="6-1-2-XML配置"><a href="#6-1-2-XML配置" class="headerlink" title="6.1.2 XML配置"></a>6.1.2 XML配置</h4><p>前面介绍了服务提供者接口的配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service interface=&quot;com.yz.dubbo.api.IUserService&quot; ref=&quot;userService1&quot; timeout=&quot;1000&quot;&gt;&lt;/dubbo:service&gt;</span><br></pre></td></tr></table></figure>

<p>当然我们只是把<code>timeout</code> 属性配置在了接口上,而接口中有那么多方法,所以我们还可以具体配置到方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service interface=&quot;com.yz.dubbo.api.IUserService&quot; ref=&quot;userService1&quot; &gt;</span><br><span class="line">	&lt;dubbo:method name=&quot;getUser&quot; timeout=&quot;2000&quot;&gt;&lt;/dubbo:method&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>这样我们就指定了<code>getUser</code> 方法<code>timeout</code> 属性</p>
<p>但是服务提供者和消费者有那么多的接口一个一个配置岂不是太麻烦,所以我们可以将一样的配置抽取出来作为服务提供者以及消费者的缺省配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:provider timeout=&quot;3000&quot;&gt;&lt;/dubbo:provider&gt;</span><br></pre></td></tr></table></figure>

<p>以 timeout 为例，显示了配置的查找顺序，其它 retries, loadbalance, actives 等类似</p>
<ul>
<li>方法级优先，接口级次之，全局配置再次之。</li>
<li>如果级别一样，则消费方优先，提供方次之。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181031220932882.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6MzU3ODIzNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中，服务提供方配置，通过 URL 经由注册中心传递给消费方。<br>建议由服务提供方设置超时，因为一个方法需要执行多长时间，服务提供方更清楚，如果一个消费方同时引用多个服务，就不需要关心每个服务的超时设置。</p>
<h3 id="6-2-启动检查"><a href="#6-2-启动检查" class="headerlink" title="6.2.启动检查"></a>6.2.启动检查</h3><p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=“true”。</p>
<p>可以通过 check=“false” 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。<br><strong>例子</strong><br>当我们没有配置检查属性的时候.只启动消费者,可以看到控制台输出错误信息 <strong>No provider</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20181101090823935.png" alt="在这里插入图片描述"></p>
<p>我们配置启动检查<code>check</code>为<code>false</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.yz.dubbo.api.IUserService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我们设置<code>check=&quot;false&quot;</code> 时,在没有提供者的情况下,消费者启动是不会报错的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;classpath:customer.xml&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">final</span> <span class="type">IUserService</span> <span class="variable">demoService</span> <span class="operator">=</span> (IUserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"><span class="comment">//        System.out.println(demoService.getUser());</span></span><br><span class="line">System.out.println(<span class="string">&quot;程序运行......&quot;</span>);</span><br><span class="line">System.in.read();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20181101091728232.png" alt="在这里插入图片描述"><br>,只有在显示调用提供者服务的时候才会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;classpath:customer.xml&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">final</span> <span class="type">IUserService</span> <span class="variable">demoService</span> <span class="operator">=</span> (IUserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">System.out.println(demoService.getUser());</span><br><span class="line">System.out.println(<span class="string">&quot;程序运行......&quot;</span>);</span><br><span class="line">System.in.read();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20181101091825618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6MzU3ODIzNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>可以看到程序报错,就是显示调用 <code>demoService.getUser()</code>这段代码导致的<br><strong>注册中心检查</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.registry.check</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过以上配置关闭服务提供者消费者对注册中心的检查,这样注册中心挂掉了,我们服务提供者消费者启动也不会报错,只是不能注册服务而已…</p>
<p><strong>例子</strong><br>当我们的注册中心挂掉的时候,我们启动服务消费者以及提供者是会报错的<br><img src="https://img-blog.csdnimg.cn/20181101093739391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6MzU3ODIzNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181101093747325.png" alt="在这里插入图片描述"></p>
<p>我们只需要配置注册中心不检查,启动就不会报错而且当注册中心重新恢复的时候他们会自动的订阅服务以及注册服务</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-超时时间"><a href="#6-3-超时时间" class="headerlink" title="6.3 超时时间"></a>6.3 超时时间</h3><p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。<br>在现实的开发中我们往往一些服务提供者的调用比较耗时,而dubbo的<code>timeout</code>缺省配置为<code>1000</code> 毫秒,也就是说当消费者调用服务提供者一秒钟还没有返回结果,则消费者会报错,如下</p>
<p><strong>提供者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IUserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUser</span><span class="params">()</span> <span class="keyword">throws</span> UserException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">User</span>[]&#123;<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;yz&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="string">&quot;hlj&quot;</span>)</span><br><span class="line">                ,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="string">&quot;zwl&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="string">&quot;ah&quot;</span>)</span><br><span class="line">                ,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>,<span class="string">&quot;hhj&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="string">&quot;zj&quot;</span>)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们模拟耗时,让提供者睡眠三秒钟,接下来启动提供者消费者<br><img src="https://img-blog.csdnimg.cn/20181101094942970.png" alt="在这里插入图片描述"></p>
<p>可以看到消费者在等待一秒后还没有结果就报错,所以在线上我们可以通过设置timeout来避免提供者服务耗时带来的问题</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.yz.dubbo.api.IUserService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userService1&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;4000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20181101095101931.png" alt="在这里插入图片描述"></p>
<p>消费者在等待三秒后,提供者服务已经被正常调用</p>
<h3 id="6-4-重试次数"><a href="#6-4-重试次数" class="headerlink" title="6.4 重试次数"></a>6.4 重试次数</h3><p>当我们服务消费者消费出现失败，可通过 <code>retries=&quot;2&quot;</code> 来设置重试次数(不含第一次)，多次调用服务提供者<br><strong>例子</strong><br>首先我们去掉之前的<code>timeout</code> 属性来模拟出错,并加上<code>retries</code> 来实现重试</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.yz.dubbo.api.IUserService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>提供者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;被调用了............&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">User</span>[]&#123;<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;yz&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="string">&quot;hlj&quot;</span>)</span><br><span class="line">            ,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="string">&quot;zwl&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="string">&quot;ah&quot;</span>)</span><br><span class="line">            ,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>,<span class="string">&quot;hhj&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="string">&quot;zj&quot;</span>)&#125;);</span><br></pre></td></tr></table></figure>

<p>接下来我们分别启动服务提供者与消费者,可以看到,我们消费者在调用失败后提供者被调用了四次<br><img src="https://img-blog.csdnimg.cn/20181101100946890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6MzU3ODIzNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181101100954964.png" alt="在这里插入图片描述"></p>
<h3 id="6-5-多版本"><a href="#6-5-多版本" class="headerlink" title="6.5 多版本"></a>6.5 多版本</h3><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>
<p>可以按照以下的步骤进行版本迁移：</p>
<ol>
<li>在低压力时间段，先升级一半提供者为新版本</li>
<li>再将所有消费者升级为新版本</li>
<li>然后将剩下的一半提供者升级为新版本</li>
</ol>
<p>也就实现了dubbo所说的灰度发布</p>
<p><strong>例子</strong><br>首先我们创建提供者接口两个不同实现</p>
<p>UserServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUser</span><span class="params">()</span> <span class="keyword">throws</span> UserException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被调用了1............&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">User</span>[]&#123;<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;yz&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="string">&quot;hlj&quot;</span>)</span><br><span class="line">                ,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="string">&quot;zwl&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="string">&quot;ah&quot;</span>)</span><br><span class="line">                ,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>,<span class="string">&quot;hhj&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="string">&quot;zj&quot;</span>)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>UserServiceImpl2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUser</span><span class="params">()</span> <span class="keyword">throws</span> UserException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被调用了2............&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">User</span>[]&#123;<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;yz&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="string">&quot;hlj&quot;</span>)</span><br><span class="line">                ,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="string">&quot;zwl&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="string">&quot;ah&quot;</span>)</span><br><span class="line">                ,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>,<span class="string">&quot;hhj&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="string">&quot;zj&quot;</span>)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>接下来在<code>provider.xml</code>配置文件中提供者接口实现指向不同的两个类,并指定不同的版本</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yz.dubbo.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yz.dubbo.impl.UserServiceImpl2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.yz.dubbo.api.IUserService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userService1&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.yz.dubbo.api.IUserService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userService2&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<p>在<code>customer.xml</code> 中指定消费者的版本号为<code>1.0.0</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.yz.dubbo.api.IUserService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20181101102642292.png" alt="在这里插入图片描述"></p>
<p>在<code>customer.xml</code> 中指定消费者的版本号为<code>2.0.0</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.yz.dubbo.api.IUserService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20181101102649226.png" alt="在这里插入图片描述"></p>
<p>可以看到了通过指定版本号分别调用了不同的接口实现,这样在实际开发中就能够实现新旧功能的过度</p>
<h2 id="7-高可用"><a href="#7-高可用" class="headerlink" title="7. 高可用"></a>7. 高可用</h2><p>之前我们说了dubbo超时重试启动检查等配置,接下来我们说一下dubbo高可用的一些配置</p>
<h3 id="7-1-zookeeper宕机"><a href="#7-1-zookeeper宕机" class="headerlink" title="7.1 zookeeper宕机"></a>7.1 zookeeper宕机</h3><p>我们接下来讨论一下如果zookeeper宕机对我们的服务提供者消费者有什么影响</p>
<p><strong>现象</strong>：zookeeper注册中心宕机，<strong>还可以消费dubbo暴露的服务</strong>。</p>
<p><strong>原因</strong>：</p>
<ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li><strong>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</strong></li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
</ul>
<p><strong>高可用：通过设计，减少系统不能提供服务的时间</strong></p>
<p><strong>例子：</strong></p>
<p>我们在消费者中睡眠20秒,然后我们在这20秒时间内停掉注册中心,看看第二次消费能否成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> </span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;classpath:customer.xml&quot;</span> &#125;);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IUserService</span> <span class="variable">demoService</span> <span class="operator">=</span> (IUserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">            System.out.println(demoService.getUser());</span><br><span class="line">            System.out.println(<span class="string">&quot;程序运行第一次......&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">20</span>);</span><br><span class="line">            System.out.println(demoService.getUser());</span><br><span class="line">            System.out.println(<span class="string">&quot;程序运行第二次......&quot;</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p>接下来我们一次启动服务提供者 消费者 然后停掉服务注册中心</p>
<p><img src="https://img-blog.csdnimg.cn/20181101181257530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6MzU3ODIzNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>可以看到</p>
<p><img src="https://img-blog.csdnimg.cn/20181101181310922.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181101181317918.png" alt="在这里插入图片描述"></p>
<p>我们的服务消费者在注册中心宕机后让然可以调用服务提供者提供的服务。但是注册中心宕机后我们不能再注册新的服务。</p>
<h3 id="7-2-Dubbo直连"><a href="#7-2-Dubbo直连" class="headerlink" title="7.2 Dubbo直连"></a>7.2 Dubbo直连</h3><p>在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。</p>
<p><strong>注意</strong> 为了避免复杂化线上环境，不要在线上使用这个功能，只应在测试阶段使用。我们可以在开发的时候使用此方式进行调试</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.yz.dubbo.api.IUserService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> <span class="attr">url</span>=<span class="string">&quot;dubbo://127.0.0.1:20882&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>基于注解方式可以在 <code>@Reference(url = ..)</code>里来配置</p>
</blockquote>
<p>我们启动我们的服务注册中心与服务提供者消费</p>
<p>发现我们的消费者并没有注册到服务注册中心,但是我们仍然可以调用服务提供者提供的服务</p>
<p><img src="https://img-blog.csdnimg.cn/20181101181333550.png" alt="在这里插入图片描述"></p>
<p>我们实现了跨注册中心 直连服务提供者</p>
<h3 id="7-3-负载均衡"><a href="#7-3-负载均衡" class="headerlink" title="7.3 负载均衡"></a>7.3 负载均衡</h3><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，<strong>默认为 Random 随机调用</strong>。</p>
<p><strong>负载均衡策略</strong></p>
<ul>
<li><p><strong>Random LoadBalance</strong></p>
<p>随机，按权重设置随机概率。</p>
</li>
<li><p><strong>RoundRobin LoadBalance</strong></p>
<p>轮询，按公约后的权重设置轮询比率。</p>
</li>
<li><p><strong>LeastActive LoadBalance</strong></p>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</p>
</li>
<li><p><strong>ConsistentHash LoadBalance</strong></p>
<p>一致性 Hash，相同参数的请求总是发到同一提供者。</p>
</li>
</ul>
<p>接下来我们测试一下默认的随机方式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消费者的xml</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.yz.dubbo.api.IUserService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userService1&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;random&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>基于注解方式可以在 <code>@Reference()</code>里的参数来配置</p>
</blockquote>
<p>我们启动多个服务提供者,并指定不同的端口号,在实现中通过来区分不同的提供者</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;被调用了1............&quot;);</span><br><span class="line">System.out.println(&quot;被调用了2............&quot;);</span><br></pre></td></tr></table></figure>

<p>接下来我们启动多个服务提供者来模拟,并通过Admin控制台中的 倍权 半权 来调节权重 ,结果如下</p>
<p><img src="https://img-blog.csdnimg.cn/20181101181342991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6MzU3ODIzNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>接下来我们启动服务消费者模拟消费者多次消费</p>
<p>我们模拟了六次可以看到控制台输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">被调用了0............</span><br><span class="line">被调用了0............</span><br><span class="line">被调用了1............</span><br><span class="line">被调用了0............</span><br><span class="line">被调用了0............</span><br><span class="line">被调用了0............</span><br></pre></td></tr></table></figure>

<p>实现了调用多个服务提供者,并实现了负载均衡</p>
<h3 id="7-4-服务降级"><a href="#7-4-服务降级" class="headerlink" title="7.4 服务降级"></a>7.4 服务降级</h3><p>当我服务器的压力比较大的时候,我们可以通过服务降级功能 临时屏蔽某个出错的非关键服务，并定义降级后的返回策略,屏蔽掉不重要的服务如广告服务等,来降低核心业务的压力</p>
<ul>
<li><code>mock=force:return+null</code> 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</li>
<li>还可以改为 <code>mock=fail:return+null</code> 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li>
</ul>
<p>我们可以直接在Admin控制台来操作服务降级和容错</p>
<blockquote>
<p>在Dubbo-Admin中</p>
<p><strong>降级</strong>：对应服务消费者中的<strong>屏蔽</strong>功能，相当于<strong>不发起远程调用</strong></p>
<p><strong>容错</strong>：对应服务消费者中的<strong>容错</strong>功能，正常调用服务提供者，但在提供者报错等<strong>调用失败时，返回null值</strong></p>
</blockquote>
<p><strong>屏蔽</strong></p>
<p>我们屏蔽我们的应用yzcustomer</p>
<p><img src="https://img-blog.csdnimg.cn/2018110118135232.png" alt="在这里插入图片描述"></p>
<p>发现提供者并没有调用且返回null<br><img src="https://img-blog.csdnimg.cn/20181101181358912.png" alt="在这里插入图片描述"></p>
<p><strong>容错</strong></p>
<p>我们容错我们的应用yzcustomer,并手动使我们的提供者出错,启动服务提供者和消费者</p>
<p><img src="https://img-blog.csdnimg.cn/20181101181405109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6MzU3ODIzNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>发现在调用服务提供者出错时,返回null</p>
<p><img src="https://img-blog.csdnimg.cn/2018110118141162.png" alt="在这里插入图片描述"></p>
<h3 id="7-5-集群容错"><a href="#7-5-集群容错" class="headerlink" title="7.5 集群容错"></a>7.5 集群容错</h3><h4 id="7-5-1-Dubbo容错方案"><a href="#7-5-1-Dubbo容错方案" class="headerlink" title="7.5.1 Dubbo容错方案"></a>7.5.1 Dubbo容错方案</h4><p>在集群调用失败时，Dubbo 提供了多种容错方案，<strong>默认为 Failover 重试</strong></p>
<p><strong>Failover Cluster</strong></p>
<p>失败自动切换，当出现失败，重试其它服务器 。通常用于读操作，但重试会带来更长延迟。可通过 <code>retries=&quot;2&quot;</code> 来设置重试次数(不含第一次)。</p>
<p><strong>Failfast Cluster</strong></p>
<p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
<p><strong>Failsafe Cluster</strong></p>
<p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
<p><strong>Failback Cluster</strong></p>
<p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
<p><strong>Forking Cluster</strong></p>
<p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</p>
<p><strong>Broadcast Cluster</strong></p>
<p>广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
<p><strong>集群模式配置</strong></p>
<p>按照以下示例在服务提供方和消费方配置集群模式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failsafe&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">&quot;failsafe&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>





<h4 id="7-5-2-整合Hystrix实现容错"><a href="#7-5-2-整合Hystrix实现容错" class="headerlink" title="7.5.2 整合Hystrix实现容错"></a>7.5.2 整合Hystrix实现容错</h4><p>简介：Hystrix旨在通过控制那些访问远程系统、服务和第三方库的节点从而对延迟和故障提供更强大的容错能力，Hystrix具备拥有回退机制和断路器功能的线程和信号隔离、请求缓存和请求打包以及监控和配置等功能。</p>
<p>1）、在pom文件中导入依赖（服务提供者和服务消费者都需要导入）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">2             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">3             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">4             <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">5         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2）、在主程序启动类上添加@EnableHystrix注解开启服务容错（服务提供者和服务消费者都需要添加）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">package</span> cn.coreqi;</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> <span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"> <span class="number">4</span> <span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"> <span class="number">5</span> <span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"> <span class="number">6</span> <span class="keyword">import</span> org.springframework.cloud.netflix.hystrix.EnableHystrix;</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span> <span class="meta">@SpringBootApplication</span></span><br><span class="line"> <span class="number">9</span> <span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="number">10</span> <span class="meta">@EnableHystrix</span>  <span class="comment">//开启服务容错</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootdubboserviceproviderApplication</span> &#123;</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span>     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="number">14</span>         SpringApplication.run(SpringbootdubboserviceproviderApplication.class, args);</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> &#125;</span><br></pre></td></tr></table></figure>



<p>3）、在服务提供者实现类中方法上添加@HystrixCommand注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">package</span> cn.coreqi.service.impl;</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> <span class="keyword">import</span> cn.coreqi.entities.User;</span><br><span class="line"> <span class="number">4</span> <span class="keyword">import</span> cn.coreqi.service.UserService;</span><br><span class="line"> <span class="number">5</span> <span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"> <span class="number">6</span> <span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"> <span class="number">7</span> <span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> <span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="number">10</span> <span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span> <span class="meta">@Component</span>  <span class="comment">//org.springframework.stereotype.Component</span></span><br><span class="line"><span class="number">13</span> <span class="meta">@Service</span>    <span class="comment">//com.alibaba.dubbo.config.annotation.Service</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span>     <span class="keyword">private</span> <span class="keyword">static</span> List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="number">17</span> </span><br><span class="line"><span class="number">18</span>     <span class="keyword">static</span> &#123;</span><br><span class="line"><span class="number">19</span>         users.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;fanqi&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">1</span>));</span><br><span class="line"><span class="number">20</span>         users.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">1</span>));</span><br><span class="line"><span class="number">21</span>         users.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>,<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">1</span>));</span><br><span class="line"><span class="number">22</span>         users.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>,<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">1</span>));</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span> 	   		</span><br><span class="line"><span class="number">25</span>		<span class="comment">//容错注解</span></span><br><span class="line"><span class="number">26</span>     <span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="number">27</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">28</span>     <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">29</span>         <span class="keyword">return</span> users;</span><br><span class="line"><span class="number">30</span>     &#125;</span><br><span class="line"><span class="number">31</span> &#125;</span><br></pre></td></tr></table></figure>



<p>4）、在服务消费者调用服务提供者的方法上添加@HystrixCommand注解并指定fallbackMethod属性，重写fallbackMethod指定的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">package</span> cn.coreqi.controller;</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> <span class="keyword">import</span> cn.coreqi.entities.User;</span><br><span class="line"> <span class="number">4</span> <span class="keyword">import</span> cn.coreqi.service.UserService;</span><br><span class="line"> <span class="number">5</span> <span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"> <span class="number">6</span> <span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"> <span class="number">7</span> <span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"> <span class="number">8</span> <span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"> <span class="number">9</span> <span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span> <span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span> <span class="meta">@Controller</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span>     <span class="meta">@Reference()</span></span><br><span class="line"><span class="number">17</span>     <span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="number">18</span> 		<span class="comment">//添加此注解</span></span><br><span class="line"><span class="number">19</span>     <span class="meta">@HystrixCommand(fallbackMethod = &quot;test1&quot;)</span></span><br><span class="line"><span class="number">20</span>     <span class="meta">@ResponseBody</span></span><br><span class="line"><span class="number">21</span>     <span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="number">22</span>     <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="number">23</span>         <span class="keyword">return</span> userService.getList();</span><br><span class="line"><span class="number">24</span>     &#125;</span><br><span class="line"><span class="number">25</span> </span><br><span class="line"><span class="number">26</span>     <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="number">27</span>         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="number">28</span>     &#125;</span><br><span class="line"><span class="number">29</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><h3 id="7-1-配置Dubbo的三种方式"><a href="#7-1-配置Dubbo的三种方式" class="headerlink" title="7.1 配置Dubbo的三种方式"></a>7.1 配置Dubbo的三种方式</h3><ul>
<li><p><code>dubbo.xml</code>来配置属性，使用<code>@ImportResource</code>导入xml配置文件</p>
</li>
<li><p><code>application.properties</code>配置属性，使用<code>@Service</code>注解暴露服务，使用<code>@Reference</code>注解来引用服务</p>
<blockquote>
<p>需要在启动类加注解<code>@EnableDubbo</code>来开启Dubbo注解的功能</p>
</blockquote>
</li>
<li><p>使用<code>@Configuration</code> 注解来编写配置类，<code>@Bean</code> 编写对应方法</p>
</li>
</ul>
<h3 id="7-2-回顾"><a href="#7-2-回顾" class="headerlink" title="7.2 回顾"></a>7.2 回顾</h3><p>本文主要介绍了</p>
<ul>
<li>Dubbo的背景</li>
<li>Dubbo和Zookeeper安装</li>
<li>Dubbo和Zookeeper的整合，创建生成者消费者</li>
<li>Dubbo-Admin、Dubbo-Monitor界面</li>
<li>Dubbo的常用配置、高可用配置</li>
</ul>
<p>在Dubbo的配置这一块中，其实还有很多。更多的东西可以在官网上进行查看学习</p>
<p>官网是自带中文版的，还是挺舒服的：<a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh/docs/">http://dubbo.apache.org/zh/docs/</a></p>
<p><img src="https://hopestation.top/upload/2020/12/dz05-8f1b9b9b91f5473faf1cd85b757b39d6.png" alt="dz05"></p>
<h2 id="8-Peace"><a href="#8-Peace" class="headerlink" title="8. Peace"></a>8. Peace</h2><h3 id="8-1-参考文献"><a href="#8-1-参考文献" class="headerlink" title="8.1 参考文献"></a>8.1 参考文献</h3><ul>
<li>官网：<a target="_blank" rel="noopener" href="http://dubbo.apache.org/%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%E2%98%86%EF%BC%89">http://dubbo.apache.org/（☆☆☆☆）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fanqisoft/category/1395663.html%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%E2%98%86%EF%BC%89">https://www.cnblogs.com/fanqisoft/category/1395663.html（☆☆☆☆）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yz357823669/category_8291803.html%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89">https://blog.csdn.net/yz357823669/category_8291803.html（☆☆☆）</a></li>
</ul>
<h4 id="8-2-其他"><a href="#8-2-其他" class="headerlink" title="8.2 其他"></a>8.2 其他</h4><blockquote>
<p>还有一些不理解的地方，以后再做补充：</p>
<ul>
<li>dubbo的本地存根</li>
<li>Dubbo-admin这个容错按钮和，dubbo整合Hystrix实现容错有什么区别</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.under2.cn/2020/12/04/RabbitMQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-rabbitmq%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="undertow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="undertow 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/04/RabbitMQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-rabbitmq%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">RabbitMQ的应用场景</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-04 15:10:44" itemprop="dateCreated datePublished" datetime="2020-12-04T15:10:44+08:00">2020-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 22:46:21" itemprop="dateModified" datetime="2022-09-22T22:46:21+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目录：<br>[TOC]</p>
<hr>
<h2 id="12-应用场景"><a href="#12-应用场景" class="headerlink" title="12. 应用场景"></a>12. 应用场景</h2><blockquote>
<p>应用场景部分转自：杨飞虎的博客 <a target="_blank" rel="noopener" href="https://blog.csdn.net/whoamiyang/article/details/54954780">https://blog.csdn.net/whoamiyang/article/details/54954780</a></p>
</blockquote>
<h3 id="12-1-背景"><a href="#12-1-背景" class="headerlink" title="12.1.背景"></a>12.1.背景</h3><p>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue)的开源实现。</p>
<h3 id="12-2-应用场景"><a href="#12-2-应用场景" class="headerlink" title="12.2.应用场景"></a>12.2.应用场景</h3><blockquote>
<p>不单单指<strong>RabbitMQ</strong>，而是指<strong>MQ</strong>（消息队列的应用场景）</p>
</blockquote>
<h4 id="12-2-1-异步处理"><a href="#12-2-1-异步处理" class="headerlink" title="12.2.1 异步处理"></a>12.2.1 异步处理</h4><p>场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种1.串行的方式;2.并行的方式<br>(1)串行方式:将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西.<br><img src="https://img-blog.csdn.net/20170209145852454?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2hvYW1peWFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(2)并行方式:将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。<br><img src="https://img-blog.csdn.net/20170209150218755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2hvYW1peWFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并性已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,英爱是写入数据库后就返回.<br>(3)消息队列<br>引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理<br><img src="https://img-blog.csdn.net/20170209150824008?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2hvYW1peWFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。</p>
<h4 id="12-2-2-应用解耦"><a href="#12-2-2-应用解耦" class="headerlink" title="12.2.2 应用解耦"></a>12.2.2 应用解耦</h4><p>场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口.<br><img src="https://img-blog.csdn.net/20170209151602258?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2hvYW1peWFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>这种做法有一个缺点:</p>
<ul>
<li>当库存系统出现故障时,订单就会失败。(这样马云将少赚好多好多钱^ ^)</li>
<li>订单系统和库存系统高耦合.<br>引入消息队列<br><img src="https://img-blog.csdn.net/20170209152116530?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2hvYW1peWFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li>
<li>订单系统:用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</li>
<li>库存系统:订阅下单的消息,获取下单消息,进行库操作。<br>就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失(马云这下高兴了).</li>
</ul>
<h4 id="12-2-3-流量削峰"><a href="#12-2-3-流量削峰" class="headerlink" title="12.2.3 流量削峰"></a>12.2.3 流量削峰</h4><p>流量削峰一般在秒杀活动中应用广泛<br>场景:秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。<br>作用:<br>1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^)<br>2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单)<br><img src="https://img-blog.csdn.net/20170209161124911?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2hvYW1peWFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.<br>2.秒杀业务根据消息队列中的请求信息，再做后续处理.</p>
<h3 id="12-3-RabbitMQ的系统架构"><a href="#12-3-RabbitMQ的系统架构" class="headerlink" title="12.3 RabbitMQ的系统架构"></a>12.3 RabbitMQ的系统架构</h3><p><img src="https://img-blog.csdn.net/20170209162609150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2hvYW1peWFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>几个概念说明:<br>Broker:它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输,<br>Exchange：消息交换机,它指定消息按什么规则,路由到哪个队列。<br>Queue:消息的载体,每个消息都会被投到一个或多个队列。<br>Binding:绑定，它的作用就是把exchange和queue按照路由规则绑定起来.<br>Routing Key:路由关键字,exchange根据这个关键字进行消息投递。<br>vhost:虚拟主机,一个broker里可以有多个vhost，用作不同用户的权限分离。<br>Producer:消息生产者,就是投递消息的程序.<br>Consumer:消息消费者,就是接受消息的程序.<br>Channel:消息通道,在客户端的每个连接里,可建立多个channel.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="undertow"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">undertow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">undertow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
